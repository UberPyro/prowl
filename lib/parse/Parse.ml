(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_prowl"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "escape_sequence",
  Some (
    Alt [|
      Nothing;
    |];
  );
  "op4", None;
  "op0", None;
  "op3", None;
  "op1", None;
  "op5", None;
  "uop", None;
  "id", None;
  "op2", None;
  "int", None;
  "string_content",
  Some (
    Alt [|
      Token (Literal " ");
      Token (Literal "\n");
      Token (Literal "\t");
      Nothing;
      Token (Name "escape_sequence");
    |];
  );
  "character_content",
  Some (
    Alt [|
      Nothing;
      Token (Name "escape_sequence");
    |];
  );
  "bop",
  Some (
    Alt [|
      Token (Name "op0");
      Token (Name "op1");
      Token (Name "op2");
      Token (Name "op3");
      Token (Name "op4");
      Token (Name "op5");
    |];
  );
  "string",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Token (Name "string_content");
      );
      Token (Literal "\"");
    ];
  );
  "char",
  Some (
    Seq [
      Token (Literal "'");
      Opt (
        Token (Name "character_content");
      );
      Token (Literal "'");
    ];
  );
  "expr",
  Some (
    Alt [|
      Repeat1 (
        Token (Name "word");
      );
      Seq [
        Token (Name "expr");
        Token (Name "op5");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "uop");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "op4");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "op3");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "op2");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "op1");
        Token (Name "expr");
      ];
      Seq [
        Token (Literal "let");
        Opt (
          Token (Literal "rec");
        );
        Repeat1 (
          Token (Name "id");
        );
        Token (Literal "=");
        Token (Name "expr");
        Token (Literal "in");
        Token (Name "expr");
      ];
      Seq [
        Token (Literal "as");
        Repeat1 (
          Token (Name "id");
        );
        Token (Literal "->");
        Token (Name "expr");
      ];
      Seq [
        Token (Name "expr");
        Token (Name "op0");
        Token (Name "expr");
      ];
    |];
  );
  "word",
  Some (
    Alt [|
      Token (Name "int");
      Token (Name "char");
      Seq [
        Token (Literal "[");
        Token (Name "expr");
        Token (Literal "]");
      ];
      Seq [
        Nothing;
        Token (Name "expr");
        Nothing;
      ];
      Seq [
        Token (Literal "{");
        Opt (
          Token (Literal ",");
        );
        Token (Name "expr");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expr");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Literal "[");
        Token (Literal "]");
      ];
      Seq [
        Nothing;
        Nothing;
      ];
      Seq [
        Token (Literal "{");
        Token (Literal "}");
      ];
      Token (Name "string");
      Token (Name "id");
      Seq [
        Nothing;
        Token (Name "bop");
        Token (Name "expr");
        Nothing;
      ];
      Seq [
        Nothing;
        Token (Name "expr");
        Token (Name "bop");
        Nothing;
      ];
      Seq [
        Nothing;
        Token (Name "bop");
        Nothing;
      ];
      Seq [
        Nothing;
        Token (Name "uop");
        Nothing;
      ];
      Seq [
        Token (Literal "[");
        Token (Name "bop");
        Token (Name "expr");
        Token (Literal "]");
      ];
      Seq [
        Token (Literal "[");
        Token (Name "expr");
        Token (Name "bop");
        Token (Literal "]");
      ];
      Seq [
        Token (Literal "[");
        Token (Name "bop");
        Token (Literal "]");
      ];
      Seq [
        Token (Literal "[");
        Token (Name "uop");
        Token (Literal "]");
      ];
    |];
  );
  "source_file",
  Some (
    Opt (
      Token (Name "expr");
    );
  );
]

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blank (
            Run.nothing v
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_op4 ((kind, body) : mt) : CST.op4 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_op0 ((kind, body) : mt) : CST.op0 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_op3 ((kind, body) : mt) : CST.op3 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_op1 ((kind, body) : mt) : CST.op1 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_op5 ((kind, body) : mt) : CST.op5 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_uop ((kind, body) : mt) : CST.uop =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_id ((kind, body) : mt) : CST.id =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_op2 ((kind, body) : mt) : CST.op2 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_int_ ((kind, body) : mt) : CST.int_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content ((kind, body) : mt) : CST.string_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `SPACE (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LF (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `HT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Blank (
            Run.nothing v
          )
      | Alt (4, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_character_content ((kind, body) : mt) : CST.character_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blank (
            Run.nothing v
          )
      | Alt (1, v) ->
          `Esc_seq (
            trans_escape_sequence (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bop ((kind, body) : mt) : CST.bop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Op0 (
            trans_op0 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Op1 (
            trans_op1 (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Op2 (
            trans_op2 (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Op3 (
            trans_op3 (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Op4 (
            trans_op4 (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Op5 (
            trans_op5 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_string_content (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_char ((kind, body) : mt) : CST.char =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_character_content (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_expr ((kind, body) : mt) : CST.expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep1_word (
            Run.repeat1
              (fun v -> trans_word (Run.matcher_token v))
              v
          )
      | Alt (1, v) ->
          `Expr_op5_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op5 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Expr_uop (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_uop (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Expr_op4_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op4 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Expr_op3_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op3 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Expr_op2_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op2 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Expr_op1_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op1 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Let_opt_rec_rep1_id_EQ_expr_in_expr (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                  ,
                  Run.repeat1
                    (fun v -> trans_id (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  trans_expr (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5),
                  trans_expr (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `As_rep1_id_DASHGT_expr (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat1
                    (fun v -> trans_id (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  trans_expr (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Expr_op0_expr (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr (Run.matcher_token v0),
                  trans_op0 (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_word ((kind, body) : mt) : CST.word =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int (
            trans_int_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Char (
            trans_char (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LBRACK_expr_RBRACK (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Blank_expr_blank (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.nothing v0,
                  trans_expr (Run.matcher_token v1),
                  Run.nothing v2
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `LCURL_opt_COMMA_expr_rep_COMMA_expr_opt_COMMA_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                  ,
                  trans_expr (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expr (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v4
                  ,
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `LBRACK_RBRACK (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Blank_blank (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.nothing v0,
                  Run.nothing v1
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `LCURL_RCURL (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Str (
            trans_string_ (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Id (
            trans_id (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Blank_bop_expr_blank (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.nothing v0,
                  trans_bop (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2),
                  Run.nothing v3
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Blank_expr_bop_blank (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.nothing v0,
                  trans_expr (Run.matcher_token v1),
                  trans_bop (Run.matcher_token v2),
                  Run.nothing v3
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Blank_bop_blank (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.nothing v0,
                  trans_bop (Run.matcher_token v1),
                  Run.nothing v2
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Blank_uop_blank (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.nothing v0,
                  trans_uop (Run.matcher_token v1),
                  Run.nothing v2
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `LBRACK_bop_expr_RBRACK (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_bop (Run.matcher_token v1),
                  trans_expr (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `LBRACK_expr_bop_RBRACK (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expr (Run.matcher_token v1),
                  trans_bop (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `LBRACK_bop_RBRACK (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_bop (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `LBRACK_uop_RBRACK (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_uop (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      Run.opt
        (fun v -> trans_expr (Run.matcher_token v))
        v
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

