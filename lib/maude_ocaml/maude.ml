[@@@warning "-8"]
[@@@warning "-39"]
[@@@warning "-33"]
[@@@warning "-38"]
[@@@warning "-27"]

(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ---------------------------------------------------------------------------- *)

open Swig
type c_enum_type = [ 
  `unknown
| `SymbolAttribute
| `TransitionType
| `SearchType
| `PrintFlags
| `ModuleType
]
type c_enum_value = [ 
  `Int of int
| `OP_ASSOC
| `OP_COMM
| `OP_ITER
| `OP_IDEM
| `OP_LEFT_ID
| `OP_RIGHT_ID
| `OP_MEMO
| `OP_SPECIAL
| `RULE_APPLICATION
| `OPAQUE_STRATEGY
| `SOLUTION
| `ONE_STEP
| `AT_LEAST_ONE_STEP
| `ANY_STEPS
| `NORMAL_FORM
| `PRINT_CONCEAL
| `PRINT_FORMAT
| `PRINT_MIXFIX
| `PRINT_WITH_PARENS
| `PRINT_COLOR
| `PRINT_DISAMBIG_CONST
| `PRINT_WITH_ALIASES
| `PRINT_FLAT
| `PRINT_NUMBER
| `PRINT_RAT
| `FUNCTIONAL_MODULE
| `SYSTEM_MODULE
| `STRATEGY_MODULE
| `FUNCTIONAL_THEORY
| `SYSTEM_THEORY
| `STRATEGY_THEORY
]

type c_obj = c_enum_value c_obj_t
let module_name = "maude"

exception BadArgs of string
exception BadMethodName of c_obj * string * string
exception NotObject of c_obj
exception NotEnumType of c_obj
exception LabelNotFromThisEnum of c_obj
exception InvalidDirectorCall of c_obj


  
  let array_to_vector v argcons array = 
    for i = 0 to (Array.length array) - 1 do
	ignore ((invoke v) "set" (C_list [ C_int i ; (argcons array.(i)) ]))
    done ;
    v
    
  let vector_to_array v argcons array =
    for i = 0; to (get_int ((invoke v) "size" C_void)) - 1 do
	array.(i) <- argcons ((invoke v) "[]" (C_int i))
    done ; 
    v
      

external _new_TokenVector_f : c_obj list -> c_obj list = "_wrap_new_TokenVectormaude" ;;
let _new_TokenVector arg = match _new_TokenVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_size_f : c_obj list -> c_obj list = "_wrap_TokenVector_sizemaude" ;;
let _TokenVector_size arg = match _TokenVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_empty_f : c_obj list -> c_obj list = "_wrap_TokenVector_emptymaude" ;;
let _TokenVector_empty arg = match _TokenVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_clear_f : c_obj list -> c_obj list = "_wrap_TokenVector_clearmaude" ;;
let _TokenVector_clear arg = match _TokenVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_push_back_f : c_obj list -> c_obj list = "_wrap_TokenVector_push_backmaude" ;;
let _TokenVector_push_back arg = match _TokenVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_TokenVector_operator_bB___maude" ;;
let _TokenVector_operator_xx_xx_lbrace_xx_rbrace arg = match _TokenVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_TokenVector_operator_e___maude" ;;
let _TokenVector_operator_xx_xx_equals arg = match _TokenVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_set_f : c_obj list -> c_obj list = "_wrap_TokenVector_setmaude" ;;
let _TokenVector_set arg = match _TokenVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TokenVector_to_array_f : c_obj list -> c_obj list = "_wrap_TokenVector_to_arraymaude" ;;
let _TokenVector_to_array arg = match _TokenVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TokenVector_f : c_obj list -> c_obj list = "_wrap_delete_TokenVectormaude" ;;
let _delete_TokenVector arg = match _delete_TokenVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_ModuleHeaderVector_f : c_obj list -> c_obj list = "_wrap_new_ModuleHeaderVectormaude" ;;
let _new_ModuleHeaderVector arg = match _new_ModuleHeaderVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_size_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_sizemaude" ;;
let _ModuleHeaderVector_size arg = match _ModuleHeaderVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_empty_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_emptymaude" ;;
let _ModuleHeaderVector_empty arg = match _ModuleHeaderVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_clear_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_clearmaude" ;;
let _ModuleHeaderVector_clear arg = match _ModuleHeaderVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_push_back_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_push_backmaude" ;;
let _ModuleHeaderVector_push_back arg = match _ModuleHeaderVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_operator_bB___maude" ;;
let _ModuleHeaderVector_operator_xx_xx_lbrace_xx_rbrace arg = match _ModuleHeaderVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_operator_e___maude" ;;
let _ModuleHeaderVector_operator_xx_xx_equals arg = match _ModuleHeaderVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_set_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_setmaude" ;;
let _ModuleHeaderVector_set arg = match _ModuleHeaderVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeaderVector_to_array_f : c_obj list -> c_obj list = "_wrap_ModuleHeaderVector_to_arraymaude" ;;
let _ModuleHeaderVector_to_array arg = match _ModuleHeaderVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ModuleHeaderVector_f : c_obj list -> c_obj list = "_wrap_delete_ModuleHeaderVectormaude" ;;
let _delete_ModuleHeaderVector arg = match _delete_ModuleHeaderVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_TermVector_f : c_obj list -> c_obj list = "_wrap_new_TermVectormaude" ;;
let _new_TermVector arg = match _new_TermVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_size_f : c_obj list -> c_obj list = "_wrap_TermVector_sizemaude" ;;
let _TermVector_size arg = match _TermVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_empty_f : c_obj list -> c_obj list = "_wrap_TermVector_emptymaude" ;;
let _TermVector_empty arg = match _TermVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_clear_f : c_obj list -> c_obj list = "_wrap_TermVector_clearmaude" ;;
let _TermVector_clear arg = match _TermVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_push_back_f : c_obj list -> c_obj list = "_wrap_TermVector_push_backmaude" ;;
let _TermVector_push_back arg = match _TermVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_TermVector_operator_bB___maude" ;;
let _TermVector_operator_xx_xx_lbrace_xx_rbrace arg = match _TermVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_TermVector_operator_e___maude" ;;
let _TermVector_operator_xx_xx_equals arg = match _TermVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_set_f : c_obj list -> c_obj list = "_wrap_TermVector_setmaude" ;;
let _TermVector_set arg = match _TermVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermVector_to_array_f : c_obj list -> c_obj list = "_wrap_TermVector_to_arraymaude" ;;
let _TermVector_to_array arg = match _TermVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TermVector_f : c_obj list -> c_obj list = "_wrap_delete_TermVectormaude" ;;
let _delete_TermVector arg = match _delete_TermVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_StringVector_f : c_obj list -> c_obj list = "_wrap_new_StringVectormaude" ;;
let _new_StringVector arg = match _new_StringVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_size_f : c_obj list -> c_obj list = "_wrap_StringVector_sizemaude" ;;
let _StringVector_size arg = match _StringVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_empty_f : c_obj list -> c_obj list = "_wrap_StringVector_emptymaude" ;;
let _StringVector_empty arg = match _StringVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_clear_f : c_obj list -> c_obj list = "_wrap_StringVector_clearmaude" ;;
let _StringVector_clear arg = match _StringVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_push_back_f : c_obj list -> c_obj list = "_wrap_StringVector_push_backmaude" ;;
let _StringVector_push_back arg = match _StringVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_StringVector_operator_bB___maude" ;;
let _StringVector_operator_xx_xx_lbrace_xx_rbrace arg = match _StringVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_StringVector_operator_e___maude" ;;
let _StringVector_operator_xx_xx_equals arg = match _StringVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_set_f : c_obj list -> c_obj list = "_wrap_StringVector_setmaude" ;;
let _StringVector_set arg = match _StringVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVector_to_array_f : c_obj list -> c_obj list = "_wrap_StringVector_to_arraymaude" ;;
let _StringVector_to_array arg = match _StringVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StringVector_f : c_obj list -> c_obj list = "_wrap_delete_StringVectormaude" ;;
let _delete_StringVector arg = match _delete_StringVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_TermPair_f : c_obj list -> c_obj list = "_wrap_new_TermPairmaude" ;;
let _new_TermPair arg = match _new_TermPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPair_first_set_f : c_obj list -> c_obj list = "_wrap_TermPair_first_setmaude" ;;
let _TermPair_first_set arg = match _TermPair_first_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPair_first_get_f : c_obj list -> c_obj list = "_wrap_TermPair_first_getmaude" ;;
let _TermPair_first_get arg = match _TermPair_first_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPair_second_set_f : c_obj list -> c_obj list = "_wrap_TermPair_second_setmaude" ;;
let _TermPair_second_set arg = match _TermPair_second_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPair_second_get_f : c_obj list -> c_obj list = "_wrap_TermPair_second_getmaude" ;;
let _TermPair_second_get arg = match _TermPair_second_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TermPair_f : c_obj list -> c_obj list = "_wrap_delete_TermPairmaude" ;;
let _delete_TermPair arg = match _delete_TermPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_TermPairVector_f : c_obj list -> c_obj list = "_wrap_new_TermPairVectormaude" ;;
let _new_TermPairVector arg = match _new_TermPairVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_size_f : c_obj list -> c_obj list = "_wrap_TermPairVector_sizemaude" ;;
let _TermPairVector_size arg = match _TermPairVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_empty_f : c_obj list -> c_obj list = "_wrap_TermPairVector_emptymaude" ;;
let _TermPairVector_empty arg = match _TermPairVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_clear_f : c_obj list -> c_obj list = "_wrap_TermPairVector_clearmaude" ;;
let _TermPairVector_clear arg = match _TermPairVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_push_back_f : c_obj list -> c_obj list = "_wrap_TermPairVector_push_backmaude" ;;
let _TermPairVector_push_back arg = match _TermPairVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_TermPairVector_operator_bB___maude" ;;
let _TermPairVector_operator_xx_xx_lbrace_xx_rbrace arg = match _TermPairVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_TermPairVector_operator_e___maude" ;;
let _TermPairVector_operator_xx_xx_equals arg = match _TermPairVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_set_f : c_obj list -> c_obj list = "_wrap_TermPairVector_setmaude" ;;
let _TermPairVector_set arg = match _TermPairVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermPairVector_to_array_f : c_obj list -> c_obj list = "_wrap_TermPairVector_to_arraymaude" ;;
let _TermPairVector_to_array arg = match _TermPairVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TermPairVector_f : c_obj list -> c_obj list = "_wrap_delete_TermPairVectormaude" ;;
let _delete_TermPairVector arg = match _delete_TermPairVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_ViewVector_f : c_obj list -> c_obj list = "_wrap_new_ViewVectormaude" ;;
let _new_ViewVector arg = match _new_ViewVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_size_f : c_obj list -> c_obj list = "_wrap_ViewVector_sizemaude" ;;
let _ViewVector_size arg = match _ViewVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_empty_f : c_obj list -> c_obj list = "_wrap_ViewVector_emptymaude" ;;
let _ViewVector_empty arg = match _ViewVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_clear_f : c_obj list -> c_obj list = "_wrap_ViewVector_clearmaude" ;;
let _ViewVector_clear arg = match _ViewVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_push_back_f : c_obj list -> c_obj list = "_wrap_ViewVector_push_backmaude" ;;
let _ViewVector_push_back arg = match _ViewVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_ViewVector_operator_bB___maude" ;;
let _ViewVector_operator_xx_xx_lbrace_xx_rbrace arg = match _ViewVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_ViewVector_operator_e___maude" ;;
let _ViewVector_operator_xx_xx_equals arg = match _ViewVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_set_f : c_obj list -> c_obj list = "_wrap_ViewVector_setmaude" ;;
let _ViewVector_set arg = match _ViewVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ViewVector_to_array_f : c_obj list -> c_obj list = "_wrap_ViewVector_to_arraymaude" ;;
let _ViewVector_to_array arg = match _ViewVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ViewVector_f : c_obj list -> c_obj list = "_wrap_delete_ViewVectormaude" ;;
let _delete_ViewVector arg = match _delete_ViewVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_IntVector_f : c_obj list -> c_obj list = "_wrap_new_IntVectormaude" ;;
let _new_IntVector arg = match _new_IntVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_size_f : c_obj list -> c_obj list = "_wrap_IntVector_sizemaude" ;;
let _IntVector_size arg = match _IntVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_empty_f : c_obj list -> c_obj list = "_wrap_IntVector_emptymaude" ;;
let _IntVector_empty arg = match _IntVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_clear_f : c_obj list -> c_obj list = "_wrap_IntVector_clearmaude" ;;
let _IntVector_clear arg = match _IntVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_push_back_f : c_obj list -> c_obj list = "_wrap_IntVector_push_backmaude" ;;
let _IntVector_push_back arg = match _IntVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_IntVector_operator_bB___maude" ;;
let _IntVector_operator_xx_xx_lbrace_xx_rbrace arg = match _IntVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_IntVector_operator_e___maude" ;;
let _IntVector_operator_xx_xx_equals arg = match _IntVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_set_f : c_obj list -> c_obj list = "_wrap_IntVector_setmaude" ;;
let _IntVector_set arg = match _IntVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _IntVector_to_array_f : c_obj list -> c_obj list = "_wrap_IntVector_to_arraymaude" ;;
let _IntVector_to_array arg = match _IntVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_IntVector_f : c_obj list -> c_obj list = "_wrap_delete_IntVectormaude" ;;
let _delete_IntVector arg = match _delete_IntVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_TermIntPair_f : c_obj list -> c_obj list = "_wrap_new_TermIntPairmaude" ;;
let _new_TermIntPair arg = match _new_TermIntPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermIntPair_first_set_f : c_obj list -> c_obj list = "_wrap_TermIntPair_first_setmaude" ;;
let _TermIntPair_first_set arg = match _TermIntPair_first_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermIntPair_first_get_f : c_obj list -> c_obj list = "_wrap_TermIntPair_first_getmaude" ;;
let _TermIntPair_first_get arg = match _TermIntPair_first_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermIntPair_second_set_f : c_obj list -> c_obj list = "_wrap_TermIntPair_second_setmaude" ;;
let _TermIntPair_second_set arg = match _TermIntPair_second_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermIntPair_second_get_f : c_obj list -> c_obj list = "_wrap_TermIntPair_second_getmaude" ;;
let _TermIntPair_second_get arg = match _TermIntPair_second_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TermIntPair_f : c_obj list -> c_obj list = "_wrap_delete_TermIntPairmaude" ;;
let _delete_TermIntPair arg = match _delete_TermIntPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_TermSubstitutionPair_f : c_obj list -> c_obj list = "_wrap_new_TermSubstitutionPairmaude" ;;
let _new_TermSubstitutionPair arg = match _new_TermSubstitutionPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermSubstitutionPair_first_set_f : c_obj list -> c_obj list = "_wrap_TermSubstitutionPair_first_setmaude" ;;
let _TermSubstitutionPair_first_set arg = match _TermSubstitutionPair_first_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermSubstitutionPair_first_get_f : c_obj list -> c_obj list = "_wrap_TermSubstitutionPair_first_getmaude" ;;
let _TermSubstitutionPair_first_get arg = match _TermSubstitutionPair_first_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermSubstitutionPair_second_set_f : c_obj list -> c_obj list = "_wrap_TermSubstitutionPair_second_setmaude" ;;
let _TermSubstitutionPair_second_set arg = match _TermSubstitutionPair_second_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _TermSubstitutionPair_second_get_f : c_obj list -> c_obj list = "_wrap_TermSubstitutionPair_second_getmaude" ;;
let _TermSubstitutionPair_second_get arg = match _TermSubstitutionPair_second_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_TermSubstitutionPair_f : c_obj list -> c_obj list = "_wrap_delete_TermSubstitutionPairmaude" ;;
let _delete_TermSubstitutionPair arg = match _delete_TermSubstitutionPair_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_StringVectorVector_f : c_obj list -> c_obj list = "_wrap_new_StringVectorVectormaude" ;;
let _new_StringVectorVector arg = match _new_StringVectorVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_size_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_sizemaude" ;;
let _StringVectorVector_size arg = match _StringVectorVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_empty_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_emptymaude" ;;
let _StringVectorVector_empty arg = match _StringVectorVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_clear_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_clearmaude" ;;
let _StringVectorVector_clear arg = match _StringVectorVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_push_back_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_push_backmaude" ;;
let _StringVectorVector_push_back arg = match _StringVectorVector_push_back_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_operator_xx_xx_lbrace_xx_rbrace_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_operator_bB___maude" ;;
let _StringVectorVector_operator_xx_xx_lbrace_xx_rbrace arg = match _StringVectorVector_operator_xx_xx_lbrace_xx_rbrace_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_operator_xx_xx_equals_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_operator_e___maude" ;;
let _StringVectorVector_operator_xx_xx_equals arg = match _StringVectorVector_operator_xx_xx_equals_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_set_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_setmaude" ;;
let _StringVectorVector_set arg = match _StringVectorVector_set_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StringVectorVector_to_array_f : c_obj list -> c_obj list = "_wrap_StringVectorVector_to_arraymaude" ;;
let _StringVectorVector_to_array arg = match _StringVectorVector_to_array_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StringVectorVector_f : c_obj list -> c_obj list = "_wrap_delete_StringVectorVectormaude" ;;
let _delete_StringVectorVector arg = match _delete_StringVectorVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_OpDeclVector_f : c_obj list -> c_obj list = "_wrap_new_OpDeclVectormaude" ;;
let _new_OpDeclVector arg = match _new_OpDeclVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_empty_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_emptymaude" ;;
let _OpDeclVector_empty arg = match _OpDeclVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_size_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_sizemaude" ;;
let _OpDeclVector_size arg = match _OpDeclVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_capacity_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_capacitymaude" ;;
let _OpDeclVector_capacity arg = match _OpDeclVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_swap_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_swapmaude" ;;
let _OpDeclVector_swap arg = match _OpDeclVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector___getitem___f : c_obj list -> c_obj list = "_wrap_OpDeclVector___getitem__maude" ;;
let _OpDeclVector___getitem__ arg = match _OpDeclVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector___setitem___f : c_obj list -> c_obj list = "_wrap_OpDeclVector___setitem__maude" ;;
let _OpDeclVector___setitem__ arg = match _OpDeclVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_append_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_appendmaude" ;;
let _OpDeclVector_append arg = match _OpDeclVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_clear_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_clearmaude" ;;
let _OpDeclVector_clear arg = match _OpDeclVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclVector_resize_f : c_obj list -> c_obj list = "_wrap_OpDeclVector_resizemaude" ;;
let _OpDeclVector_resize arg = match _OpDeclVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_OpDeclVector_f : c_obj list -> c_obj list = "_wrap_delete_OpDeclVectormaude" ;;
let _delete_OpDeclVector arg = match _delete_OpDeclVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_SortVector_f : c_obj list -> c_obj list = "_wrap_new_SortVectormaude" ;;
let _new_SortVector arg = match _new_SortVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_empty_f : c_obj list -> c_obj list = "_wrap_SortVector_emptymaude" ;;
let _SortVector_empty arg = match _SortVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_size_f : c_obj list -> c_obj list = "_wrap_SortVector_sizemaude" ;;
let _SortVector_size arg = match _SortVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_capacity_f : c_obj list -> c_obj list = "_wrap_SortVector_capacitymaude" ;;
let _SortVector_capacity arg = match _SortVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_swap_f : c_obj list -> c_obj list = "_wrap_SortVector_swapmaude" ;;
let _SortVector_swap arg = match _SortVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector___getitem___f : c_obj list -> c_obj list = "_wrap_SortVector___getitem__maude" ;;
let _SortVector___getitem__ arg = match _SortVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector___setitem___f : c_obj list -> c_obj list = "_wrap_SortVector___setitem__maude" ;;
let _SortVector___setitem__ arg = match _SortVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_append_f : c_obj list -> c_obj list = "_wrap_SortVector_appendmaude" ;;
let _SortVector_append arg = match _SortVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_clear_f : c_obj list -> c_obj list = "_wrap_SortVector_clearmaude" ;;
let _SortVector_clear arg = match _SortVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortVector_resize_f : c_obj list -> c_obj list = "_wrap_SortVector_resizemaude" ;;
let _SortVector_resize arg = match _SortVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_SortVector_f : c_obj list -> c_obj list = "_wrap_delete_SortVectormaude" ;;
let _delete_SortVector arg = match _delete_SortVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_SymbolVector_f : c_obj list -> c_obj list = "_wrap_new_SymbolVectormaude" ;;
let _new_SymbolVector arg = match _new_SymbolVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_empty_f : c_obj list -> c_obj list = "_wrap_SymbolVector_emptymaude" ;;
let _SymbolVector_empty arg = match _SymbolVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_size_f : c_obj list -> c_obj list = "_wrap_SymbolVector_sizemaude" ;;
let _SymbolVector_size arg = match _SymbolVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_capacity_f : c_obj list -> c_obj list = "_wrap_SymbolVector_capacitymaude" ;;
let _SymbolVector_capacity arg = match _SymbolVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_swap_f : c_obj list -> c_obj list = "_wrap_SymbolVector_swapmaude" ;;
let _SymbolVector_swap arg = match _SymbolVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector___getitem___f : c_obj list -> c_obj list = "_wrap_SymbolVector___getitem__maude" ;;
let _SymbolVector___getitem__ arg = match _SymbolVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector___setitem___f : c_obj list -> c_obj list = "_wrap_SymbolVector___setitem__maude" ;;
let _SymbolVector___setitem__ arg = match _SymbolVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_append_f : c_obj list -> c_obj list = "_wrap_SymbolVector_appendmaude" ;;
let _SymbolVector_append arg = match _SymbolVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_clear_f : c_obj list -> c_obj list = "_wrap_SymbolVector_clearmaude" ;;
let _SymbolVector_clear arg = match _SymbolVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SymbolVector_resize_f : c_obj list -> c_obj list = "_wrap_SymbolVector_resizemaude" ;;
let _SymbolVector_resize arg = match _SymbolVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_SymbolVector_f : c_obj list -> c_obj list = "_wrap_delete_SymbolVectormaude" ;;
let _delete_SymbolVector arg = match _delete_SymbolVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_KindVector_f : c_obj list -> c_obj list = "_wrap_new_KindVectormaude" ;;
let _new_KindVector arg = match _new_KindVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_empty_f : c_obj list -> c_obj list = "_wrap_KindVector_emptymaude" ;;
let _KindVector_empty arg = match _KindVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_size_f : c_obj list -> c_obj list = "_wrap_KindVector_sizemaude" ;;
let _KindVector_size arg = match _KindVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_capacity_f : c_obj list -> c_obj list = "_wrap_KindVector_capacitymaude" ;;
let _KindVector_capacity arg = match _KindVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_swap_f : c_obj list -> c_obj list = "_wrap_KindVector_swapmaude" ;;
let _KindVector_swap arg = match _KindVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector___getitem___f : c_obj list -> c_obj list = "_wrap_KindVector___getitem__maude" ;;
let _KindVector___getitem__ arg = match _KindVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector___setitem___f : c_obj list -> c_obj list = "_wrap_KindVector___setitem__maude" ;;
let _KindVector___setitem__ arg = match _KindVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_append_f : c_obj list -> c_obj list = "_wrap_KindVector_appendmaude" ;;
let _KindVector_append arg = match _KindVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_clear_f : c_obj list -> c_obj list = "_wrap_KindVector_clearmaude" ;;
let _KindVector_clear arg = match _KindVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _KindVector_resize_f : c_obj list -> c_obj list = "_wrap_KindVector_resizemaude" ;;
let _KindVector_resize arg = match _KindVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_KindVector_f : c_obj list -> c_obj list = "_wrap_delete_KindVectormaude" ;;
let _delete_KindVector arg = match _delete_KindVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_SubsortVector_f : c_obj list -> c_obj list = "_wrap_new_SubsortVectormaude" ;;
let _new_SubsortVector arg = match _new_SubsortVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_empty_f : c_obj list -> c_obj list = "_wrap_SubsortVector_emptymaude" ;;
let _SubsortVector_empty arg = match _SubsortVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_size_f : c_obj list -> c_obj list = "_wrap_SubsortVector_sizemaude" ;;
let _SubsortVector_size arg = match _SubsortVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_capacity_f : c_obj list -> c_obj list = "_wrap_SubsortVector_capacitymaude" ;;
let _SubsortVector_capacity arg = match _SubsortVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_swap_f : c_obj list -> c_obj list = "_wrap_SubsortVector_swapmaude" ;;
let _SubsortVector_swap arg = match _SubsortVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector___getitem___f : c_obj list -> c_obj list = "_wrap_SubsortVector___getitem__maude" ;;
let _SubsortVector___getitem__ arg = match _SubsortVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector___setitem___f : c_obj list -> c_obj list = "_wrap_SubsortVector___setitem__maude" ;;
let _SubsortVector___setitem__ arg = match _SubsortVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_append_f : c_obj list -> c_obj list = "_wrap_SubsortVector_appendmaude" ;;
let _SubsortVector_append arg = match _SubsortVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_clear_f : c_obj list -> c_obj list = "_wrap_SubsortVector_clearmaude" ;;
let _SubsortVector_clear arg = match _SubsortVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SubsortVector_resize_f : c_obj list -> c_obj list = "_wrap_SubsortVector_resizemaude" ;;
let _SubsortVector_resize arg = match _SubsortVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_SubsortVector_f : c_obj list -> c_obj list = "_wrap_delete_SubsortVectormaude" ;;
let _delete_SubsortVector arg = match _delete_SubsortVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_EquationVector_f : c_obj list -> c_obj list = "_wrap_new_EquationVectormaude" ;;
let _new_EquationVector arg = match _new_EquationVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_empty_f : c_obj list -> c_obj list = "_wrap_EquationVector_emptymaude" ;;
let _EquationVector_empty arg = match _EquationVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_size_f : c_obj list -> c_obj list = "_wrap_EquationVector_sizemaude" ;;
let _EquationVector_size arg = match _EquationVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_capacity_f : c_obj list -> c_obj list = "_wrap_EquationVector_capacitymaude" ;;
let _EquationVector_capacity arg = match _EquationVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_swap_f : c_obj list -> c_obj list = "_wrap_EquationVector_swapmaude" ;;
let _EquationVector_swap arg = match _EquationVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector___getitem___f : c_obj list -> c_obj list = "_wrap_EquationVector___getitem__maude" ;;
let _EquationVector___getitem__ arg = match _EquationVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector___setitem___f : c_obj list -> c_obj list = "_wrap_EquationVector___setitem__maude" ;;
let _EquationVector___setitem__ arg = match _EquationVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_append_f : c_obj list -> c_obj list = "_wrap_EquationVector_appendmaude" ;;
let _EquationVector_append arg = match _EquationVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_clear_f : c_obj list -> c_obj list = "_wrap_EquationVector_clearmaude" ;;
let _EquationVector_clear arg = match _EquationVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EquationVector_resize_f : c_obj list -> c_obj list = "_wrap_EquationVector_resizemaude" ;;
let _EquationVector_resize arg = match _EquationVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_EquationVector_f : c_obj list -> c_obj list = "_wrap_delete_EquationVectormaude" ;;
let _delete_EquationVector arg = match _delete_EquationVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_RuleVector_f : c_obj list -> c_obj list = "_wrap_new_RuleVectormaude" ;;
let _new_RuleVector arg = match _new_RuleVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_empty_f : c_obj list -> c_obj list = "_wrap_RuleVector_emptymaude" ;;
let _RuleVector_empty arg = match _RuleVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_size_f : c_obj list -> c_obj list = "_wrap_RuleVector_sizemaude" ;;
let _RuleVector_size arg = match _RuleVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_capacity_f : c_obj list -> c_obj list = "_wrap_RuleVector_capacitymaude" ;;
let _RuleVector_capacity arg = match _RuleVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_swap_f : c_obj list -> c_obj list = "_wrap_RuleVector_swapmaude" ;;
let _RuleVector_swap arg = match _RuleVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector___getitem___f : c_obj list -> c_obj list = "_wrap_RuleVector___getitem__maude" ;;
let _RuleVector___getitem__ arg = match _RuleVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector___setitem___f : c_obj list -> c_obj list = "_wrap_RuleVector___setitem__maude" ;;
let _RuleVector___setitem__ arg = match _RuleVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_append_f : c_obj list -> c_obj list = "_wrap_RuleVector_appendmaude" ;;
let _RuleVector_append arg = match _RuleVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_clear_f : c_obj list -> c_obj list = "_wrap_RuleVector_clearmaude" ;;
let _RuleVector_clear arg = match _RuleVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RuleVector_resize_f : c_obj list -> c_obj list = "_wrap_RuleVector_resizemaude" ;;
let _RuleVector_resize arg = match _RuleVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RuleVector_f : c_obj list -> c_obj list = "_wrap_delete_RuleVectormaude" ;;
let _delete_RuleVector arg = match _delete_RuleVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_StratVector_f : c_obj list -> c_obj list = "_wrap_new_StratVectormaude" ;;
let _new_StratVector arg = match _new_StratVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_empty_f : c_obj list -> c_obj list = "_wrap_StratVector_emptymaude" ;;
let _StratVector_empty arg = match _StratVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_size_f : c_obj list -> c_obj list = "_wrap_StratVector_sizemaude" ;;
let _StratVector_size arg = match _StratVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_capacity_f : c_obj list -> c_obj list = "_wrap_StratVector_capacitymaude" ;;
let _StratVector_capacity arg = match _StratVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_swap_f : c_obj list -> c_obj list = "_wrap_StratVector_swapmaude" ;;
let _StratVector_swap arg = match _StratVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector___getitem___f : c_obj list -> c_obj list = "_wrap_StratVector___getitem__maude" ;;
let _StratVector___getitem__ arg = match _StratVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector___setitem___f : c_obj list -> c_obj list = "_wrap_StratVector___setitem__maude" ;;
let _StratVector___setitem__ arg = match _StratVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_append_f : c_obj list -> c_obj list = "_wrap_StratVector_appendmaude" ;;
let _StratVector_append arg = match _StratVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_clear_f : c_obj list -> c_obj list = "_wrap_StratVector_clearmaude" ;;
let _StratVector_clear arg = match _StratVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratVector_resize_f : c_obj list -> c_obj list = "_wrap_StratVector_resizemaude" ;;
let _StratVector_resize arg = match _StratVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StratVector_f : c_obj list -> c_obj list = "_wrap_delete_StratVectormaude" ;;
let _delete_StratVector arg = match _delete_StratVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_StratDefVector_f : c_obj list -> c_obj list = "_wrap_new_StratDefVectormaude" ;;
let _new_StratDefVector arg = match _new_StratDefVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_empty_f : c_obj list -> c_obj list = "_wrap_StratDefVector_emptymaude" ;;
let _StratDefVector_empty arg = match _StratDefVector_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_size_f : c_obj list -> c_obj list = "_wrap_StratDefVector_sizemaude" ;;
let _StratDefVector_size arg = match _StratDefVector_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_capacity_f : c_obj list -> c_obj list = "_wrap_StratDefVector_capacitymaude" ;;
let _StratDefVector_capacity arg = match _StratDefVector_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_swap_f : c_obj list -> c_obj list = "_wrap_StratDefVector_swapmaude" ;;
let _StratDefVector_swap arg = match _StratDefVector_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector___getitem___f : c_obj list -> c_obj list = "_wrap_StratDefVector___getitem__maude" ;;
let _StratDefVector___getitem__ arg = match _StratDefVector___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector___setitem___f : c_obj list -> c_obj list = "_wrap_StratDefVector___setitem__maude" ;;
let _StratDefVector___setitem__ arg = match _StratDefVector___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_append_f : c_obj list -> c_obj list = "_wrap_StratDefVector_appendmaude" ;;
let _StratDefVector_append arg = match _StratDefVector_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_clear_f : c_obj list -> c_obj list = "_wrap_StratDefVector_clearmaude" ;;
let _StratDefVector_clear arg = match _StratDefVector_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StratDefVector_resize_f : c_obj list -> c_obj list = "_wrap_StratDefVector_resizemaude" ;;
let _StratDefVector_resize arg = match _StratDefVector_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StratDefVector_f : c_obj list -> c_obj list = "_wrap_delete_StratDefVectormaude" ;;
let _delete_StratDefVector arg = match _delete_StratDefVector_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Condition_f : c_obj list -> c_obj list = "_wrap_new_Conditionmaude" ;;
let _new_Condition arg = match _new_Condition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_empty_f : c_obj list -> c_obj list = "_wrap_Condition_emptymaude" ;;
let _Condition_empty arg = match _Condition_empty_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_size_f : c_obj list -> c_obj list = "_wrap_Condition_sizemaude" ;;
let _Condition_size arg = match _Condition_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_capacity_f : c_obj list -> c_obj list = "_wrap_Condition_capacitymaude" ;;
let _Condition_capacity arg = match _Condition_capacity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_swap_f : c_obj list -> c_obj list = "_wrap_Condition_swapmaude" ;;
let _Condition_swap arg = match _Condition_swap_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition___getitem___f : c_obj list -> c_obj list = "_wrap_Condition___getitem__maude" ;;
let _Condition___getitem__ arg = match _Condition___getitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition___setitem___f : c_obj list -> c_obj list = "_wrap_Condition___setitem__maude" ;;
let _Condition___setitem__ arg = match _Condition___setitem___f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_append_f : c_obj list -> c_obj list = "_wrap_Condition_appendmaude" ;;
let _Condition_append arg = match _Condition_append_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_clear_f : c_obj list -> c_obj list = "_wrap_Condition_clearmaude" ;;
let _Condition_clear arg = match _Condition_clear_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Condition_resize_f : c_obj list -> c_obj list = "_wrap_Condition_resizemaude" ;;
let _Condition_resize arg = match _Condition_resize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Condition_f : c_obj list -> c_obj list = "_wrap_delete_Conditionmaude" ;;
let _delete_Condition arg = match _delete_Condition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _init_f : c_obj list -> c_obj list = "_wrap_initmaude" ;;
let _init arg = match _init_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _load_f : c_obj list -> c_obj list = "_wrap_loadmaude" ;;
let _load arg = match _load_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _input_f : c_obj list -> c_obj list = "_wrap_inputmaude" ;;
let _input arg = match _input_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _getCurrentModule_f : c_obj list -> c_obj list = "_wrap_getCurrentModulemaude" ;;
let _getCurrentModule arg = match _getCurrentModule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _getModule_f : c_obj list -> c_obj list = "_wrap_getModulemaude" ;;
let _getModule arg = match _getModule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _downModule_f : c_obj list -> c_obj list = "_wrap_downModulemaude" ;;
let _downModule arg = match _downModule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _tokenize_f : c_obj list -> c_obj list = "_wrap_tokenizemaude" ;;
let _tokenize arg = match _tokenize_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _getModules_f : c_obj list -> c_obj list = "_wrap_getModulesmaude" ;;
let _getModules arg = match _getModules_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _getView_f : c_obj list -> c_obj list = "_wrap_getViewmaude" ;;
let _getView arg = match _getView_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _getViews_f : c_obj list -> c_obj list = "_wrap_getViewsmaude" ;;
let _getViews arg = match _getViews_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeader_type_get_f : c_obj list -> c_obj list = "_wrap_ModuleHeader_type_getmaude" ;;
let _ModuleHeader_type_get arg = match _ModuleHeader_type_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModuleHeader_name_get_f : c_obj list -> c_obj list = "_wrap_ModuleHeader_name_getmaude" ;;
let _ModuleHeader_name_get arg = match _ModuleHeader_name_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_ModuleHeader_f : c_obj list -> c_obj list = "_wrap_new_ModuleHeadermaude" ;;
let _new_ModuleHeader arg = match _new_ModuleHeader_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ModuleHeader_f : c_obj list -> c_obj list = "_wrap_delete_ModuleHeadermaude" ;;
let _delete_ModuleHeader arg = match _delete_ModuleHeader_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _setAllowProcesses_f : c_obj list -> c_obj list = "_wrap_setAllowProcessesmaude" ;;
let _setAllowProcesses arg = match _setAllowProcesses_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _setAllowFiles_f : c_obj list -> c_obj list = "_wrap_setAllowFilesmaude" ;;
let _setAllowFiles arg = match _setAllowFiles_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _setAllowDir_f : c_obj list -> c_obj list = "_wrap_setAllowDirmaude" ;;
let _setAllowDir arg = match _setAllowDir_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _setRandomSeed_f : c_obj list -> c_obj list = "_wrap_setRandomSeedmaude" ;;
let _setRandomSeed arg = match _setRandomSeed_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _setAssocUnifDepth_f : c_obj list -> c_obj list = "_wrap_setAssocUnifDepthmaude" ;;
let _setAssocUnifDepth arg = match _setAssocUnifDepth_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _UNBOUNDED : c_obj -> Swig.c_obj = "_wrap_UNBOUNDED" 
external _ModuleItem_getModule_f : c_obj list -> c_obj list = "_wrap_ModuleItem_getModulemaude" ;;
let _ModuleItem_getModule arg = match _ModuleItem_getModule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ModuleItem_f : c_obj list -> c_obj list = "_wrap_delete_ModuleItemmaude" ;;
let _delete_ModuleItem arg = match _delete_ModuleItem_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getLhs_f : c_obj list -> c_obj list = "_wrap_Equation_getLhsmaude" ;;
let _Equation_getLhs arg = match _Equation_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getRhs_f : c_obj list -> c_obj list = "_wrap_Equation_getRhsmaude" ;;
let _Equation_getRhs arg = match _Equation_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getLabel_f : c_obj list -> c_obj list = "_wrap_Equation_getLabelmaude" ;;
let _Equation_getLabel arg = match _Equation_getLabel_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_isNonexec_f : c_obj list -> c_obj list = "_wrap_Equation_isNonexecmaude" ;;
let _Equation_isNonexec arg = match _Equation_isNonexec_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_isOwise_f : c_obj list -> c_obj list = "_wrap_Equation_isOwisemaude" ;;
let _Equation_isOwise arg = match _Equation_isOwise_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_isVariant_f : c_obj list -> c_obj list = "_wrap_Equation_isVariantmaude" ;;
let _Equation_isVariant arg = match _Equation_isVariant_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_hasCondition_f : c_obj list -> c_obj list = "_wrap_Equation_hasConditionmaude" ;;
let _Equation_hasCondition arg = match _Equation_hasCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getCondition_f : c_obj list -> c_obj list = "_wrap_Equation_getConditionmaude" ;;
let _Equation_getCondition arg = match _Equation_getCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getMetadata_f : c_obj list -> c_obj list = "_wrap_Equation_getMetadatamaude" ;;
let _Equation_getMetadata arg = match _Equation_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_getLineNumber_f : c_obj list -> c_obj list = "_wrap_Equation_getLineNumbermaude" ;;
let _Equation_getLineNumber arg = match _Equation_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_hash_f : c_obj list -> c_obj list = "_wrap_Equation_hashmaude" ;;
let _Equation_hash arg = match _Equation_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Equation_equal_f : c_obj list -> c_obj list = "_wrap_Equation_equalmaude" ;;
let _Equation_equal arg = match _Equation_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Equation_f : c_obj list -> c_obj list = "_wrap_delete_Equationmaude" ;;
let _delete_Equation arg = match _delete_Equation_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_kind_f : c_obj list -> c_obj list = "_wrap_Sort_kindmaude" ;;
let _Sort_kind arg = match _Sort_kind_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_getSubsorts_f : c_obj list -> c_obj list = "_wrap_Sort_getSubsortsmaude" ;;
let _Sort_getSubsorts arg = match _Sort_getSubsorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_getSupersorts_f : c_obj list -> c_obj list = "_wrap_Sort_getSupersortsmaude" ;;
let _Sort_getSupersorts arg = match _Sort_getSupersorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_leq_f : c_obj list -> c_obj list = "_wrap_Sort_leqmaude" ;;
let _Sort_leq arg = match _Sort_leq_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_getLineNumber_f : c_obj list -> c_obj list = "_wrap_Sort_getLineNumbermaude" ;;
let _Sort_getLineNumber arg = match _Sort_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_hash_f : c_obj list -> c_obj list = "_wrap_Sort_hashmaude" ;;
let _Sort_hash arg = match _Sort_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Sort_equal_f : c_obj list -> c_obj list = "_wrap_Sort_equalmaude" ;;
let _Sort_equal arg = match _Sort_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Sort_f : c_obj list -> c_obj list = "_wrap_delete_Sortmaude" ;;
let _delete_Sort arg = match _delete_Sort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_nrSorts_f : c_obj list -> c_obj list = "_wrap_Kind_nrSortsmaude" ;;
let _Kind_nrSorts arg = match _Kind_nrSorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_nrMaximalSorts_f : c_obj list -> c_obj list = "_wrap_Kind_nrMaximalSortsmaude" ;;
let _Kind_nrMaximalSorts arg = match _Kind_nrMaximalSorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_sort_f : c_obj list -> c_obj list = "_wrap_Kind_sortmaude" ;;
let _Kind_sort arg = match _Kind_sort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_errorFree_f : c_obj list -> c_obj list = "_wrap_Kind_errorFreemaude" ;;
let _Kind_errorFree arg = match _Kind_errorFree_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_hash_f : c_obj list -> c_obj list = "_wrap_Kind_hashmaude" ;;
let _Kind_hash arg = match _Kind_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Kind_equal_f : c_obj list -> c_obj list = "_wrap_Kind_equalmaude" ;;
let _Kind_equal arg = match _Kind_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Kind_f : c_obj list -> c_obj list = "_wrap_delete_Kindmaude" ;;
let _delete_Kind arg = match _delete_Kind_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getLhs_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getLhsmaude" ;;
let _MembershipAxiom_getLhs arg = match _MembershipAxiom_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getSort_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getSortmaude" ;;
let _MembershipAxiom_getSort arg = match _MembershipAxiom_getSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getCondition_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getConditionmaude" ;;
let _MembershipAxiom_getCondition arg = match _MembershipAxiom_getCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_isNonexec_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_isNonexecmaude" ;;
let _MembershipAxiom_isNonexec arg = match _MembershipAxiom_isNonexec_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getLabel_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getLabelmaude" ;;
let _MembershipAxiom_getLabel arg = match _MembershipAxiom_getLabel_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getMetadata_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getMetadatamaude" ;;
let _MembershipAxiom_getMetadata arg = match _MembershipAxiom_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_getLineNumber_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_getLineNumbermaude" ;;
let _MembershipAxiom_getLineNumber arg = match _MembershipAxiom_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_hash_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_hashmaude" ;;
let _MembershipAxiom_hash arg = match _MembershipAxiom_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MembershipAxiom_equal_f : c_obj list -> c_obj list = "_wrap_MembershipAxiom_equalmaude" ;;
let _MembershipAxiom_equal arg = match _MembershipAxiom_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_MembershipAxiom_f : c_obj list -> c_obj list = "_wrap_delete_MembershipAxiommaude" ;;
let _delete_MembershipAxiom arg = match _delete_MembershipAxiom_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
let _ = Callback.register "SymbolAttribute_marker" (`SymbolAttribute)
external _OP_ASSOC : c_obj -> Swig.c_obj = "_wrap_OP_ASSOC" 
external _OP_COMM : c_obj -> Swig.c_obj = "_wrap_OP_COMM" 
external _OP_ITER : c_obj -> Swig.c_obj = "_wrap_OP_ITER" 
external _OP_IDEM : c_obj -> Swig.c_obj = "_wrap_OP_IDEM" 
external _OP_LEFT_ID : c_obj -> Swig.c_obj = "_wrap_OP_LEFT_ID" 
external _OP_RIGHT_ID : c_obj -> Swig.c_obj = "_wrap_OP_RIGHT_ID" 
external _OP_MEMO : c_obj -> Swig.c_obj = "_wrap_OP_MEMO" 
external _OP_SPECIAL : c_obj -> Swig.c_obj = "_wrap_OP_SPECIAL" 
external _Symbol_arity_f : c_obj list -> c_obj list = "_wrap_Symbol_aritymaude" ;;
let _Symbol_arity arg = match _Symbol_arity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_domainKind_f : c_obj list -> c_obj list = "_wrap_Symbol_domainKindmaude" ;;
let _Symbol_domainKind arg = match _Symbol_domainKind_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getRangeSort_f : c_obj list -> c_obj list = "_wrap_Symbol_getRangeSortmaude" ;;
let _Symbol_getRangeSort arg = match _Symbol_getRangeSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_hash_f : c_obj list -> c_obj list = "_wrap_Symbol_hashmaude" ;;
let _Symbol_hash arg = match _Symbol_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_equal_f : c_obj list -> c_obj list = "_wrap_Symbol_equalmaude" ;;
let _Symbol_equal arg = match _Symbol_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getOpDeclarations_f : c_obj list -> c_obj list = "_wrap_Symbol_getOpDeclarationsmaude" ;;
let _Symbol_getOpDeclarations arg = match _Symbol_getOpDeclarations_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_makeTerm_f : c_obj list -> c_obj list = "_wrap_Symbol_makeTermmaude" ;;
let _Symbol_makeTerm arg = match _Symbol_makeTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getMetadata_f : c_obj list -> c_obj list = "_wrap_Symbol_getMetadatamaude" ;;
let _Symbol_getMetadata arg = match _Symbol_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_isAssoc_f : c_obj list -> c_obj list = "_wrap_Symbol_isAssocmaude" ;;
let _Symbol_isAssoc arg = match _Symbol_isAssoc_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_hasAttr_f : c_obj list -> c_obj list = "_wrap_Symbol_hasAttrmaude" ;;
let _Symbol_hasAttr arg = match _Symbol_hasAttr_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getIdentity_f : c_obj list -> c_obj list = "_wrap_Symbol_getIdentitymaude" ;;
let _Symbol_getIdentity arg = match _Symbol_getIdentity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getStrategy_f : c_obj list -> c_obj list = "_wrap_Symbol_getStrategymaude" ;;
let _Symbol_getStrategy arg = match _Symbol_getStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getFrozen_f : c_obj list -> c_obj list = "_wrap_Symbol_getFrozenmaude" ;;
let _Symbol_getFrozen arg = match _Symbol_getFrozen_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getFormat_f : c_obj list -> c_obj list = "_wrap_Symbol_getFormatmaude" ;;
let _Symbol_getFormat arg = match _Symbol_getFormat_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getPrec_f : c_obj list -> c_obj list = "_wrap_Symbol_getPrecmaude" ;;
let _Symbol_getPrec arg = match _Symbol_getPrec_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getIdHooks_f : c_obj list -> c_obj list = "_wrap_Symbol_getIdHooksmaude" ;;
let _Symbol_getIdHooks arg = match _Symbol_getIdHooks_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Symbol_getLineNumber_f : c_obj list -> c_obj list = "_wrap_Symbol_getLineNumbermaude" ;;
let _Symbol_getLineNumber arg = match _Symbol_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Symbol_f : c_obj list -> c_obj list = "_wrap_delete_Symbolmaude" ;;
let _delete_Symbol arg = match _delete_Symbol_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclaration_getDomainAndRange_f : c_obj list -> c_obj list = "_wrap_OpDeclaration_getDomainAndRangemaude" ;;
let _OpDeclaration_getDomainAndRange arg = match _OpDeclaration_getDomainAndRange_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _OpDeclaration_isConstructor_f : c_obj list -> c_obj list = "_wrap_OpDeclaration_isConstructormaude" ;;
let _OpDeclaration_isConstructor arg = match _OpDeclaration_isConstructor_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_OpDeclaration_f : c_obj list -> c_obj list = "_wrap_delete_OpDeclarationmaude" ;;
let _delete_OpDeclaration arg = match _delete_OpDeclaration_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_OpDeclaration_f : c_obj list -> c_obj list = "_wrap_new_OpDeclarationmaude" ;;
let _new_OpDeclaration arg = match _new_OpDeclaration_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getLhs_f : c_obj list -> c_obj list = "_wrap_Rule_getLhsmaude" ;;
let _Rule_getLhs arg = match _Rule_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getRhs_f : c_obj list -> c_obj list = "_wrap_Rule_getRhsmaude" ;;
let _Rule_getRhs arg = match _Rule_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getLabel_f : c_obj list -> c_obj list = "_wrap_Rule_getLabelmaude" ;;
let _Rule_getLabel arg = match _Rule_getLabel_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_isNarrowing_f : c_obj list -> c_obj list = "_wrap_Rule_isNarrowingmaude" ;;
let _Rule_isNarrowing arg = match _Rule_isNarrowing_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_isNonexec_f : c_obj list -> c_obj list = "_wrap_Rule_isNonexecmaude" ;;
let _Rule_isNonexec arg = match _Rule_isNonexec_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_hasCondition_f : c_obj list -> c_obj list = "_wrap_Rule_hasConditionmaude" ;;
let _Rule_hasCondition arg = match _Rule_hasCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getCondition_f : c_obj list -> c_obj list = "_wrap_Rule_getConditionmaude" ;;
let _Rule_getCondition arg = match _Rule_getCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getMetadata_f : c_obj list -> c_obj list = "_wrap_Rule_getMetadatamaude" ;;
let _Rule_getMetadata arg = match _Rule_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_getLineNumber_f : c_obj list -> c_obj list = "_wrap_Rule_getLineNumbermaude" ;;
let _Rule_getLineNumber arg = match _Rule_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_hash_f : c_obj list -> c_obj list = "_wrap_Rule_hashmaude" ;;
let _Rule_hash arg = match _Rule_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Rule_equal_f : c_obj list -> c_obj list = "_wrap_Rule_equalmaude" ;;
let _Rule_equal arg = match _Rule_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Rule_f : c_obj list -> c_obj list = "_wrap_delete_Rulemaude" ;;
let _delete_Rule arg = match _delete_Rule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategyExpression_f : c_obj list -> c_obj list = "_wrap_delete_StrategyExpressionmaude" ;;
let _delete_StrategyExpression arg = match _delete_StrategyExpression_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyExpression_equal_f : c_obj list -> c_obj list = "_wrap_StrategyExpression_equalmaude" ;;
let _StrategyExpression_equal arg = match _StrategyExpression_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getDomain_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getDomainmaude" ;;
let _RewriteStrategy_getDomain arg = match _RewriteStrategy_getDomain_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getSubjectSort_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getSubjectSortmaude" ;;
let _RewriteStrategy_getSubjectSort arg = match _RewriteStrategy_getSubjectSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getDefinitions_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getDefinitionsmaude" ;;
let _RewriteStrategy_getDefinitions arg = match _RewriteStrategy_getDefinitions_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_arity_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_aritymaude" ;;
let _RewriteStrategy_arity arg = match _RewriteStrategy_arity_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getName_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getNamemaude" ;;
let _RewriteStrategy_getName arg = match _RewriteStrategy_getName_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getMetadata_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getMetadatamaude" ;;
let _RewriteStrategy_getMetadata arg = match _RewriteStrategy_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_getLineNumber_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_getLineNumbermaude" ;;
let _RewriteStrategy_getLineNumber arg = match _RewriteStrategy_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_hash_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_hashmaude" ;;
let _RewriteStrategy_hash arg = match _RewriteStrategy_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteStrategy_equal_f : c_obj list -> c_obj list = "_wrap_RewriteStrategy_equalmaude" ;;
let _RewriteStrategy_equal arg = match _RewriteStrategy_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RewriteStrategy_f : c_obj list -> c_obj list = "_wrap_delete_RewriteStrategymaude" ;;
let _delete_RewriteStrategy arg = match _delete_RewriteStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getLhs_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getLhsmaude" ;;
let _StrategyDefinition_getLhs arg = match _StrategyDefinition_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getRhs_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getRhsmaude" ;;
let _StrategyDefinition_getRhs arg = match _StrategyDefinition_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getStrategy_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getStrategymaude" ;;
let _StrategyDefinition_getStrategy arg = match _StrategyDefinition_getStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_isNonexec_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_isNonexecmaude" ;;
let _StrategyDefinition_isNonexec arg = match _StrategyDefinition_isNonexec_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_hasCondition_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_hasConditionmaude" ;;
let _StrategyDefinition_hasCondition arg = match _StrategyDefinition_hasCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getCondition_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getConditionmaude" ;;
let _StrategyDefinition_getCondition arg = match _StrategyDefinition_getCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getLabel_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getLabelmaude" ;;
let _StrategyDefinition_getLabel arg = match _StrategyDefinition_getLabel_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getMetadata_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getMetadatamaude" ;;
let _StrategyDefinition_getMetadata arg = match _StrategyDefinition_getMetadata_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_getLineNumber_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_getLineNumbermaude" ;;
let _StrategyDefinition_getLineNumber arg = match _StrategyDefinition_getLineNumber_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_hash_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_hashmaude" ;;
let _StrategyDefinition_hash arg = match _StrategyDefinition_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyDefinition_equal_f : c_obj list -> c_obj list = "_wrap_StrategyDefinition_equalmaude" ;;
let _StrategyDefinition_equal arg = match _StrategyDefinition_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategyDefinition_f : c_obj list -> c_obj list = "_wrap_delete_StrategyDefinitionmaude" ;;
let _delete_StrategyDefinition arg = match _delete_StrategyDefinition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Token_name_f : c_obj list -> c_obj list = "_wrap_Token_namemaude" ;;
let _Token_name arg = match _Token_name_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Token_f : c_obj list -> c_obj list = "_wrap_new_Tokenmaude" ;;
let _new_Token arg = match _new_Token_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Token_REPR_METHOD_f : c_obj list -> c_obj list = "_wrap_Token_REPR_METHODmaude" ;;
let _Token_REPR_METHOD arg = match _Token_REPR_METHOD_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Token_f : c_obj list -> c_obj list = "_wrap_delete_Tokenmaude" ;;
let _delete_Token arg = match _delete_Token_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ConditionFragment_f : c_obj list -> c_obj list = "_wrap_delete_ConditionFragmentmaude" ;;
let _delete_ConditionFragment arg = match _delete_ConditionFragment_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_EqualityCondition_f : c_obj list -> c_obj list = "_wrap_new_EqualityConditionmaude" ;;
let _new_EqualityCondition arg = match _new_EqualityCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EqualityCondition_getLhs_f : c_obj list -> c_obj list = "_wrap_EqualityCondition_getLhsmaude" ;;
let _EqualityCondition_getLhs arg = match _EqualityCondition_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _EqualityCondition_getRhs_f : c_obj list -> c_obj list = "_wrap_EqualityCondition_getRhsmaude" ;;
let _EqualityCondition_getRhs arg = match _EqualityCondition_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_EqualityCondition_f : c_obj list -> c_obj list = "_wrap_delete_EqualityConditionmaude" ;;
let _delete_EqualityCondition arg = match _delete_EqualityCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_AssignmentCondition_f : c_obj list -> c_obj list = "_wrap_new_AssignmentConditionmaude" ;;
let _new_AssignmentCondition arg = match _new_AssignmentCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _AssignmentCondition_getLhs_f : c_obj list -> c_obj list = "_wrap_AssignmentCondition_getLhsmaude" ;;
let _AssignmentCondition_getLhs arg = match _AssignmentCondition_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _AssignmentCondition_getRhs_f : c_obj list -> c_obj list = "_wrap_AssignmentCondition_getRhsmaude" ;;
let _AssignmentCondition_getRhs arg = match _AssignmentCondition_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_AssignmentCondition_f : c_obj list -> c_obj list = "_wrap_delete_AssignmentConditionmaude" ;;
let _delete_AssignmentCondition arg = match _delete_AssignmentCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_RewriteCondition_f : c_obj list -> c_obj list = "_wrap_new_RewriteConditionmaude" ;;
let _new_RewriteCondition arg = match _new_RewriteCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteCondition_getLhs_f : c_obj list -> c_obj list = "_wrap_RewriteCondition_getLhsmaude" ;;
let _RewriteCondition_getLhs arg = match _RewriteCondition_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteCondition_getRhs_f : c_obj list -> c_obj list = "_wrap_RewriteCondition_getRhsmaude" ;;
let _RewriteCondition_getRhs arg = match _RewriteCondition_getRhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RewriteCondition_f : c_obj list -> c_obj list = "_wrap_delete_RewriteConditionmaude" ;;
let _delete_RewriteCondition arg = match _delete_RewriteCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_SortTestCondition_f : c_obj list -> c_obj list = "_wrap_new_SortTestConditionmaude" ;;
let _new_SortTestCondition arg = match _new_SortTestCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortTestCondition_getLhs_f : c_obj list -> c_obj list = "_wrap_SortTestCondition_getLhsmaude" ;;
let _SortTestCondition_getLhs arg = match _SortTestCondition_getLhs_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _SortTestCondition_getSort_f : c_obj list -> c_obj list = "_wrap_SortTestCondition_getSortmaude" ;;
let _SortTestCondition_getSort arg = match _SortTestCondition_getSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_SortTestCondition_f : c_obj list -> c_obj list = "_wrap_delete_SortTestConditionmaude" ;;
let _delete_SortTestCondition arg = match _delete_SortTestCondition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModelCheckResult_holds_get_f : c_obj list -> c_obj list = "_wrap_ModelCheckResult_holds_getmaude" ;;
let _ModelCheckResult_holds_get arg = match _ModelCheckResult_holds_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModelCheckResult_leadIn_get_f : c_obj list -> c_obj list = "_wrap_ModelCheckResult_leadIn_getmaude" ;;
let _ModelCheckResult_leadIn_get arg = match _ModelCheckResult_leadIn_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModelCheckResult_cycle_get_f : c_obj list -> c_obj list = "_wrap_ModelCheckResult_cycle_getmaude" ;;
let _ModelCheckResult_cycle_get arg = match _ModelCheckResult_cycle_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ModelCheckResult_nrBuchiStates_get_f : c_obj list -> c_obj list = "_wrap_ModelCheckResult_nrBuchiStates_getmaude" ;;
let _ModelCheckResult_nrBuchiStates_get arg = match _ModelCheckResult_nrBuchiStates_get_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_ModelCheckResult_f : c_obj list -> c_obj list = "_wrap_new_ModelCheckResultmaude" ;;
let _new_ModelCheckResult arg = match _new_ModelCheckResult_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ModelCheckResult_f : c_obj list -> c_obj list = "_wrap_delete_ModelCheckResultmaude" ;;
let _delete_ModelCheckResult arg = match _delete_ModelCheckResult_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_RewriteGraph_f : c_obj list -> c_obj list = "_wrap_new_RewriteGraphmaude" ;;
let _new_RewriteGraph arg = match _new_RewriteGraph_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getStateTerm_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getStateTermmaude" ;;
let _RewriteGraph_getStateTerm arg = match _RewriteGraph_getStateTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getRule_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getRulemaude" ;;
let _RewriteGraph_getRule arg = match _RewriteGraph_getRule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getNrRewrites_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getNrRewritesmaude" ;;
let _RewriteGraph_getNrRewrites arg = match _RewriteGraph_getNrRewrites_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_modelCheck_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_modelCheckmaude" ;;
let _RewriteGraph_modelCheck arg = match _RewriteGraph_modelCheck_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getNrStates_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getNrStatesmaude" ;;
let _RewriteGraph_getNrStates arg = match _RewriteGraph_getNrStates_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getNextState_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getNextStatemaude" ;;
let _RewriteGraph_getNextState arg = match _RewriteGraph_getNextState_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteGraph_getStateParent_f : c_obj list -> c_obj list = "_wrap_RewriteGraph_getStateParentmaude" ;;
let _RewriteGraph_getStateParent arg = match _RewriteGraph_getStateParent_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RewriteGraph_f : c_obj list -> c_obj list = "_wrap_delete_RewriteGraphmaude" ;;
let _delete_RewriteGraph arg = match _delete_RewriteGraph_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
let _ = Callback.register "StrategyTransitionGraph::TransitionType_marker" (`TransitionType)
external _RULE_APPLICATION : c_obj -> Swig.c_obj = "_wrap_RULE_APPLICATION" 
external _OPAQUE_STRATEGY : c_obj -> Swig.c_obj = "_wrap_OPAQUE_STRATEGY" 
external _SOLUTION : c_obj -> Swig.c_obj = "_wrap_SOLUTION" 
external _new_StrategyRewriteGraph_f : c_obj list -> c_obj list = "_wrap_new_StrategyRewriteGraphmaude" ;;
let _new_StrategyRewriteGraph arg = match _new_StrategyRewriteGraph_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getStateTerm_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getStateTermmaude" ;;
let _StrategyRewriteGraph_getStateTerm arg = match _StrategyRewriteGraph_getStateTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getStateStrategy_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getStateStrategymaude" ;;
let _StrategyRewriteGraph_getStateStrategy arg = match _StrategyRewriteGraph_getStateStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getTransition_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getTransitionmaude" ;;
let _StrategyRewriteGraph_getTransition arg = match _StrategyRewriteGraph_getTransition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getNrRewrites_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getNrRewritesmaude" ;;
let _StrategyRewriteGraph_getNrRewrites arg = match _StrategyRewriteGraph_getNrRewrites_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_modelCheck_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_modelCheckmaude" ;;
let _StrategyRewriteGraph_modelCheck arg = match _StrategyRewriteGraph_modelCheck_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getNrStates_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getNrStatesmaude" ;;
let _StrategyRewriteGraph_getNrStates arg = match _StrategyRewriteGraph_getNrStates_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getNrRealStates_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getNrRealStatesmaude" ;;
let _StrategyRewriteGraph_getNrRealStates arg = match _StrategyRewriteGraph_getNrRealStates_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_getNextState_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_getNextStatemaude" ;;
let _StrategyRewriteGraph_getNextState arg = match _StrategyRewriteGraph_getNextState_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyRewriteGraph_isSolutionState_f : c_obj list -> c_obj list = "_wrap_StrategyRewriteGraph_isSolutionStatemaude" ;;
let _StrategyRewriteGraph_isSolutionState arg = match _StrategyRewriteGraph_isSolutionState_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategyRewriteGraph_f : c_obj list -> c_obj list = "_wrap_delete_StrategyRewriteGraphmaude" ;;
let _delete_StrategyRewriteGraph arg = match _delete_StrategyRewriteGraph_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyGraphTransition_getType_f : c_obj list -> c_obj list = "_wrap_StrategyGraphTransition_getTypemaude" ;;
let _StrategyGraphTransition_getType arg = match _StrategyGraphTransition_getType_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyGraphTransition_getRule_f : c_obj list -> c_obj list = "_wrap_StrategyGraphTransition_getRulemaude" ;;
let _StrategyGraphTransition_getRule arg = match _StrategyGraphTransition_getRule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyGraphTransition_getStrategy_f : c_obj list -> c_obj list = "_wrap_StrategyGraphTransition_getStrategymaude" ;;
let _StrategyGraphTransition_getStrategy arg = match _StrategyGraphTransition_getStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategyGraphTransition_REPR_METHOD_f : c_obj list -> c_obj list = "_wrap_StrategyGraphTransition_REPR_METHODmaude" ;;
let _StrategyGraphTransition_REPR_METHOD arg = match _StrategyGraphTransition_REPR_METHOD_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategyGraphTransition_f : c_obj list -> c_obj list = "_wrap_delete_StrategyGraphTransitionmaude" ;;
let _delete_StrategyGraphTransition arg = match _delete_StrategyGraphTransition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
let _ = Callback.register "SearchType_marker" (`SearchType)
external _ONE_STEP : c_obj -> Swig.c_obj = "_wrap_ONE_STEP" 
external _AT_LEAST_ONE_STEP : c_obj -> Swig.c_obj = "_wrap_AT_LEAST_ONE_STEP" 
external _ANY_STEPS : c_obj -> Swig.c_obj = "_wrap_ANY_STEPS" 
external _NORMAL_FORM : c_obj -> Swig.c_obj = "_wrap_NORMAL_FORM" 
let _ = Callback.register "PrintFlags_marker" (`PrintFlags)
external _PRINT_CONCEAL : c_obj -> Swig.c_obj = "_wrap_PRINT_CONCEAL" 
external _PRINT_FORMAT : c_obj -> Swig.c_obj = "_wrap_PRINT_FORMAT" 
external _PRINT_MIXFIX : c_obj -> Swig.c_obj = "_wrap_PRINT_MIXFIX" 
external _PRINT_WITH_PARENS : c_obj -> Swig.c_obj = "_wrap_PRINT_WITH_PARENS" 
external _PRINT_COLOR : c_obj -> Swig.c_obj = "_wrap_PRINT_COLOR" 
external _PRINT_DISAMBIG_CONST : c_obj -> Swig.c_obj = "_wrap_PRINT_DISAMBIG_CONST" 
external _PRINT_WITH_ALIASES : c_obj -> Swig.c_obj = "_wrap_PRINT_WITH_ALIASES" 
external _PRINT_FLAT : c_obj -> Swig.c_obj = "_wrap_PRINT_FLAT" 
external _PRINT_NUMBER : c_obj -> Swig.c_obj = "_wrap_PRINT_NUMBER" 
external _PRINT_RAT : c_obj -> Swig.c_obj = "_wrap_PRINT_RAT" 
external _delete_Term_f : c_obj list -> c_obj list = "_wrap_delete_Termmaude" ;;
let _delete_Term arg = match _delete_Term_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_symbol_f : c_obj list -> c_obj list = "_wrap_Term_symbolmaude" ;;
let _Term_symbol arg = match _Term_symbol_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_ground_f : c_obj list -> c_obj list = "_wrap_Term_groundmaude" ;;
let _Term_ground arg = match _Term_ground_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_equal_f : c_obj list -> c_obj list = "_wrap_Term_equalmaude" ;;
let _Term_equal arg = match _Term_equal_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_leq_f : c_obj list -> c_obj list = "_wrap_Term_leqmaude" ;;
let _Term_leq arg = match _Term_leq_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_getSort_f : c_obj list -> c_obj list = "_wrap_Term_getSortmaude" ;;
let _Term_getSort arg = match _Term_getSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_reduce_f : c_obj list -> c_obj list = "_wrap_Term_reducemaude" ;;
let _Term_reduce arg = match _Term_reduce_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_rewrite_f : c_obj list -> c_obj list = "_wrap_Term_rewritemaude" ;;
let _Term_rewrite arg = match _Term_rewrite_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_frewrite_f : c_obj list -> c_obj list = "_wrap_Term_frewritemaude" ;;
let _Term_frewrite arg = match _Term_frewrite_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_erewrite_f : c_obj list -> c_obj list = "_wrap_Term_erewritemaude" ;;
let _Term_erewrite arg = match _Term_erewrite_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_match_f : c_obj list -> c_obj list = "_wrap_Term_matchmaude" ;;
let _Term_match arg = match _Term_match_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_srewrite_f : c_obj list -> c_obj list = "_wrap_Term_srewritemaude" ;;
let _Term_srewrite arg = match _Term_srewrite_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_search_f : c_obj list -> c_obj list = "_wrap_Term_searchmaude" ;;
let _Term_search arg = match _Term_search_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_get_variants_f : c_obj list -> c_obj list = "_wrap_Term_get_variantsmaude" ;;
let _Term_get_variants arg = match _Term_get_variants_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_vu_narrow_f : c_obj list -> c_obj list = "_wrap_Term_vu_narrowmaude" ;;
let _Term_vu_narrow arg = match _Term_vu_narrow_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_apply_f : c_obj list -> c_obj list = "_wrap_Term_applymaude" ;;
let _Term_apply arg = match _Term_apply_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_check_f : c_obj list -> c_obj list = "_wrap_Term_checkmaude" ;;
let _Term_check arg = match _Term_check_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_arguments_f : c_obj list -> c_obj list = "_wrap_Term_argumentsmaude" ;;
let _Term_arguments arg = match _Term_arguments_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_toFloat_f : c_obj list -> c_obj list = "_wrap_Term_toFloatmaude" ;;
let _Term_toFloat arg = match _Term_toFloat_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_toInt_f : c_obj list -> c_obj list = "_wrap_Term_toIntmaude" ;;
let _Term_toInt arg = match _Term_toInt_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_isVariable_f : c_obj list -> c_obj list = "_wrap_Term_isVariablemaude" ;;
let _Term_isVariable arg = match _Term_isVariable_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_getVarName_f : c_obj list -> c_obj list = "_wrap_Term_getVarNamemaude" ;;
let _Term_getVarName arg = match _Term_getVarName_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_getIterExponent_f : c_obj list -> c_obj list = "_wrap_Term_getIterExponentmaude" ;;
let _Term_getIterExponent arg = match _Term_getIterExponent_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_hash_f : c_obj list -> c_obj list = "_wrap_Term_hashmaude" ;;
let _Term_hash arg = match _Term_hash_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_copy_f : c_obj list -> c_obj list = "_wrap_Term_copymaude" ;;
let _Term_copy arg = match _Term_copy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Term_NO_CONDITION : c_obj -> Swig.c_obj = "_wrap_Term_NO_CONDITION" 
external _Term_prettyPrint_f : c_obj list -> c_obj list = "_wrap_Term_prettyPrintmaude" ;;
let _Term_prettyPrint arg = match _Term_prettyPrint_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategicSearch_getRewriteCount_f : c_obj list -> c_obj list = "_wrap_StrategicSearch_getRewriteCountmaude" ;;
let _StrategicSearch_getRewriteCount arg = match _StrategicSearch_getRewriteCount_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategicSearch___next_f : c_obj list -> c_obj list = "_wrap_StrategicSearch___nextmaude" ;;
let _StrategicSearch___next arg = match _StrategicSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategicSearch_f : c_obj list -> c_obj list = "_wrap_delete_StrategicSearchmaude" ;;
let _delete_StrategicSearch arg = match _delete_StrategicSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Substitution_f : c_obj list -> c_obj list = "_wrap_new_Substitutionmaude" ;;
let _new_Substitution arg = match _new_Substitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_size_f : c_obj list -> c_obj list = "_wrap_Substitution_sizemaude" ;;
let _Substitution_size arg = match _Substitution_size_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_value_f : c_obj list -> c_obj list = "_wrap_Substitution_valuemaude" ;;
let _Substitution_value arg = match _Substitution_value_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_matchedPortion_f : c_obj list -> c_obj list = "_wrap_Substitution_matchedPortionmaude" ;;
let _Substitution_matchedPortion arg = match _Substitution_matchedPortion_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_find_f : c_obj list -> c_obj list = "_wrap_Substitution_findmaude" ;;
let _Substitution_find arg = match _Substitution_find_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_instantiate_f : c_obj list -> c_obj list = "_wrap_Substitution_instantiatemaude" ;;
let _Substitution_instantiate arg = match _Substitution_instantiate_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Substitution_iterator_f : c_obj list -> c_obj list = "_wrap_Substitution_iteratormaude" ;;
let _Substitution_iterator arg = match _Substitution_iterator_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Substitution_f : c_obj list -> c_obj list = "_wrap_delete_Substitutionmaude" ;;
let _delete_Substitution arg = match _delete_Substitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Iterator_nextAssignment_f : c_obj list -> c_obj list = "_wrap_Iterator_nextAssignmentmaude" ;;
let _Iterator_nextAssignment arg = match _Iterator_nextAssignment_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Iterator_getVariable_f : c_obj list -> c_obj list = "_wrap_Iterator_getVariablemaude" ;;
let _Iterator_getVariable arg = match _Iterator_getVariable_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Iterator_getValue_f : c_obj list -> c_obj list = "_wrap_Iterator_getValuemaude" ;;
let _Iterator_getValue arg = match _Iterator_getValue_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Iterator_f : c_obj list -> c_obj list = "_wrap_delete_Iteratormaude" ;;
let _delete_Iterator arg = match _delete_Iterator_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MatchSearchState___next_f : c_obj list -> c_obj list = "_wrap_MatchSearchState___nextmaude" ;;
let _MatchSearchState___next arg = match _MatchSearchState___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _MatchSearchState_fillContext_f : c_obj list -> c_obj list = "_wrap_MatchSearchState_fillContextmaude" ;;
let _MatchSearchState_fillContext arg = match _MatchSearchState_fillContext_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_MatchSearchState_f : c_obj list -> c_obj list = "_wrap_delete_MatchSearchStatemaude" ;;
let _delete_MatchSearchState arg = match _delete_MatchSearchState_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getRewriteCount_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getRewriteCountmaude" ;;
let _RewriteSequenceSearch_getRewriteCount arg = match _RewriteSequenceSearch_getRewriteCount_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getSubstitution_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getSubstitutionmaude" ;;
let _RewriteSequenceSearch_getSubstitution arg = match _RewriteSequenceSearch_getSubstitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getRule_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getRulemaude" ;;
let _RewriteSequenceSearch_getRule arg = match _RewriteSequenceSearch_getRule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getStateTerm_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getStateTermmaude" ;;
let _RewriteSequenceSearch_getStateTerm arg = match _RewriteSequenceSearch_getStateTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch___next_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch___nextmaude" ;;
let _RewriteSequenceSearch___next arg = match _RewriteSequenceSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getStateNr_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getStateNrmaude" ;;
let _RewriteSequenceSearch_getStateNr arg = match _RewriteSequenceSearch_getStateNr_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSequenceSearch_getStateParent_f : c_obj list -> c_obj list = "_wrap_RewriteSequenceSearch_getStateParentmaude" ;;
let _RewriteSequenceSearch_getStateParent arg = match _RewriteSequenceSearch_getStateParent_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RewriteSequenceSearch_f : c_obj list -> c_obj list = "_wrap_delete_RewriteSequenceSearchmaude" ;;
let _delete_RewriteSequenceSearch arg = match _delete_RewriteSequenceSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getRewriteCount_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getRewriteCountmaude" ;;
let _StrategySequenceSearch_getRewriteCount arg = match _StrategySequenceSearch_getRewriteCount_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getSubstitution_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getSubstitutionmaude" ;;
let _StrategySequenceSearch_getSubstitution arg = match _StrategySequenceSearch_getSubstitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getTransition_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getTransitionmaude" ;;
let _StrategySequenceSearch_getTransition arg = match _StrategySequenceSearch_getTransition_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getStateTerm_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getStateTermmaude" ;;
let _StrategySequenceSearch_getStateTerm arg = match _StrategySequenceSearch_getStateTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getStrategyContinuation_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getStrategyContinuationmaude" ;;
let _StrategySequenceSearch_getStrategyContinuation arg = match _StrategySequenceSearch_getStrategyContinuation_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch___next_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch___nextmaude" ;;
let _StrategySequenceSearch___next arg = match _StrategySequenceSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getStateNr_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getStateNrmaude" ;;
let _StrategySequenceSearch_getStateNr arg = match _StrategySequenceSearch_getStateNr_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _StrategySequenceSearch_getStateParent_f : c_obj list -> c_obj list = "_wrap_StrategySequenceSearch_getStateParentmaude" ;;
let _StrategySequenceSearch_getStateParent arg = match _StrategySequenceSearch_getStateParent_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_StrategySequenceSearch_f : c_obj list -> c_obj list = "_wrap_delete_StrategySequenceSearchmaude" ;;
let _delete_StrategySequenceSearch arg = match _delete_StrategySequenceSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _NarrowingSequenceSearch_isIncomplete_f : c_obj list -> c_obj list = "_wrap_NarrowingSequenceSearch_isIncompletemaude" ;;
let _NarrowingSequenceSearch_isIncomplete arg = match _NarrowingSequenceSearch_isIncomplete_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _NarrowingSequenceSearch___next_f : c_obj list -> c_obj list = "_wrap_NarrowingSequenceSearch___nextmaude" ;;
let _NarrowingSequenceSearch___next arg = match _NarrowingSequenceSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _NarrowingSequenceSearch_getSubstitution_f : c_obj list -> c_obj list = "_wrap_NarrowingSequenceSearch_getSubstitutionmaude" ;;
let _NarrowingSequenceSearch_getSubstitution arg = match _NarrowingSequenceSearch_getSubstitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _NarrowingSequenceSearch_getUnifier_f : c_obj list -> c_obj list = "_wrap_NarrowingSequenceSearch_getUnifiermaude" ;;
let _NarrowingSequenceSearch_getUnifier arg = match _NarrowingSequenceSearch_getUnifier_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_NarrowingSequenceSearch_f : c_obj list -> c_obj list = "_wrap_delete_NarrowingSequenceSearchmaude" ;;
let _delete_NarrowingSequenceSearch arg = match _delete_NarrowingSequenceSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _VariantSearch_isIncomplete_f : c_obj list -> c_obj list = "_wrap_VariantSearch_isIncompletemaude" ;;
let _VariantSearch_isIncomplete arg = match _VariantSearch_isIncomplete_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _VariantSearch___next_f : c_obj list -> c_obj list = "_wrap_VariantSearch___nextmaude" ;;
let _VariantSearch___next arg = match _VariantSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_VariantSearch_f : c_obj list -> c_obj list = "_wrap_delete_VariantSearchmaude" ;;
let _delete_VariantSearch arg = match _delete_VariantSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSearchState_getRule_f : c_obj list -> c_obj list = "_wrap_RewriteSearchState_getRulemaude" ;;
let _RewriteSearchState_getRule arg = match _RewriteSearchState_getRule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSearchState___next_f : c_obj list -> c_obj list = "_wrap_RewriteSearchState___nextmaude" ;;
let _RewriteSearchState___next arg = match _RewriteSearchState___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSearchState_getSubstitution_f : c_obj list -> c_obj list = "_wrap_RewriteSearchState_getSubstitutionmaude" ;;
let _RewriteSearchState_getSubstitution arg = match _RewriteSearchState_getSubstitution_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _RewriteSearchState_fillContext_f : c_obj list -> c_obj list = "_wrap_RewriteSearchState_fillContextmaude" ;;
let _RewriteSearchState_fillContext arg = match _RewriteSearchState_fillContext_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_RewriteSearchState_f : c_obj list -> c_obj list = "_wrap_delete_RewriteSearchStatemaude" ;;
let _delete_RewriteSearchState arg = match _delete_RewriteSearchState_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ArgumentIterator_valid_f : c_obj list -> c_obj list = "_wrap_ArgumentIterator_validmaude" ;;
let _ArgumentIterator_valid arg = match _ArgumentIterator_valid_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ArgumentIterator___next_f : c_obj list -> c_obj list = "_wrap_ArgumentIterator___nextmaude" ;;
let _ArgumentIterator___next arg = match _ArgumentIterator___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _ArgumentIterator_argument_f : c_obj list -> c_obj list = "_wrap_ArgumentIterator_argumentmaude" ;;
let _ArgumentIterator_argument arg = match _ArgumentIterator_argument_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_ArgumentIterator_f : c_obj list -> c_obj list = "_wrap_delete_ArgumentIteratormaude" ;;
let _delete_ArgumentIterator arg = match _delete_ArgumentIterator_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Module_f : c_obj list -> c_obj list = "_wrap_delete_Modulemaude" ;;
let _delete_Module arg = match _delete_Module_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
let _ = Callback.register "VisibleModule::ModuleType_marker" (`ModuleType)
external _FUNCTIONAL_MODULE : c_obj -> Swig.c_obj = "_wrap_FUNCTIONAL_MODULE" 
external _SYSTEM_MODULE : c_obj -> Swig.c_obj = "_wrap_SYSTEM_MODULE" 
external _STRATEGY_MODULE : c_obj -> Swig.c_obj = "_wrap_STRATEGY_MODULE" 
external _FUNCTIONAL_THEORY : c_obj -> Swig.c_obj = "_wrap_FUNCTIONAL_THEORY" 
external _SYSTEM_THEORY : c_obj -> Swig.c_obj = "_wrap_SYSTEM_THEORY" 
external _STRATEGY_THEORY : c_obj -> Swig.c_obj = "_wrap_STRATEGY_THEORY" 
external _Module_getModuleType_f : c_obj list -> c_obj list = "_wrap_Module_getModuleTypemaude" ;;
let _Module_getModuleType arg = match _Module_getModuleType_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getSorts_f : c_obj list -> c_obj list = "_wrap_Module_getSortsmaude" ;;
let _Module_getSorts arg = match _Module_getSorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getSymbols_f : c_obj list -> c_obj list = "_wrap_Module_getSymbolsmaude" ;;
let _Module_getSymbols arg = match _Module_getSymbols_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getKinds_f : c_obj list -> c_obj list = "_wrap_Module_getKindsmaude" ;;
let _Module_getKinds arg = match _Module_getKinds_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getMembershipAxioms_f : c_obj list -> c_obj list = "_wrap_Module_getMembershipAxiomsmaude" ;;
let _Module_getMembershipAxioms arg = match _Module_getMembershipAxioms_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getEquations_f : c_obj list -> c_obj list = "_wrap_Module_getEquationsmaude" ;;
let _Module_getEquations arg = match _Module_getEquations_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getRules_f : c_obj list -> c_obj list = "_wrap_Module_getRulesmaude" ;;
let _Module_getRules arg = match _Module_getRules_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getStrategies_f : c_obj list -> c_obj list = "_wrap_Module_getStrategiesmaude" ;;
let _Module_getStrategies arg = match _Module_getStrategies_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getStrategyDefinitions_f : c_obj list -> c_obj list = "_wrap_Module_getStrategyDefinitionsmaude" ;;
let _Module_getStrategyDefinitions arg = match _Module_getStrategyDefinitions_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrParameters_f : c_obj list -> c_obj list = "_wrap_Module_getNrParametersmaude" ;;
let _Module_getNrParameters arg = match _Module_getNrParameters_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_hasFreeParameters_f : c_obj list -> c_obj list = "_wrap_Module_hasFreeParametersmaude" ;;
let _Module_hasFreeParameters arg = match _Module_hasFreeParameters_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrImportedSorts_f : c_obj list -> c_obj list = "_wrap_Module_getNrImportedSortsmaude" ;;
let _Module_getNrImportedSorts arg = match _Module_getNrImportedSorts_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrImportedSymbols_f : c_obj list -> c_obj list = "_wrap_Module_getNrImportedSymbolsmaude" ;;
let _Module_getNrImportedSymbols arg = match _Module_getNrImportedSymbols_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrImportedStrategies_f : c_obj list -> c_obj list = "_wrap_Module_getNrImportedStrategiesmaude" ;;
let _Module_getNrImportedStrategies arg = match _Module_getNrImportedStrategies_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrOriginalEquations_f : c_obj list -> c_obj list = "_wrap_Module_getNrOriginalEquationsmaude" ;;
let _Module_getNrOriginalEquations arg = match _Module_getNrOriginalEquations_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrOriginalRules_f : c_obj list -> c_obj list = "_wrap_Module_getNrOriginalRulesmaude" ;;
let _Module_getNrOriginalRules arg = match _Module_getNrOriginalRules_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getNrOriginalStrategyDefinitions_f : c_obj list -> c_obj list = "_wrap_Module_getNrOriginalStrategyDefinitionsmaude" ;;
let _Module_getNrOriginalStrategyDefinitions arg = match _Module_getNrOriginalStrategyDefinitions_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getParameterTheory_f : c_obj list -> c_obj list = "_wrap_Module_getParameterTheorymaude" ;;
let _Module_getParameterTheory arg = match _Module_getParameterTheory_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_getParameterName_f : c_obj list -> c_obj list = "_wrap_Module_getParameterNamemaude" ;;
let _Module_getParameterName arg = match _Module_getParameterName_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_findSort_f : c_obj list -> c_obj list = "_wrap_Module_findSortmaude" ;;
let _Module_findSort arg = match _Module_findSort_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_findSymbol_f : c_obj list -> c_obj list = "_wrap_Module_findSymbolmaude" ;;
let _Module_findSymbol arg = match _Module_findSymbol_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_parseTerm_f : c_obj list -> c_obj list = "_wrap_Module_parseTermmaude" ;;
let _Module_parseTerm arg = match _Module_parseTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_parseStrategy_f : c_obj list -> c_obj list = "_wrap_Module_parseStrategymaude" ;;
let _Module_parseStrategy arg = match _Module_parseStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_downTerm_f : c_obj list -> c_obj list = "_wrap_Module_downTermmaude" ;;
let _Module_downTerm arg = match _Module_downTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_downStrategy_f : c_obj list -> c_obj list = "_wrap_Module_downStrategymaude" ;;
let _Module_downStrategy arg = match _Module_downStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_upTerm_f : c_obj list -> c_obj list = "_wrap_Module_upTermmaude" ;;
let _Module_upTerm arg = match _Module_upTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_upStrategy_f : c_obj list -> c_obj list = "_wrap_Module_upStrategymaude" ;;
let _Module_upStrategy arg = match _Module_upStrategy_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_unify_f : c_obj list -> c_obj list = "_wrap_Module_unifymaude" ;;
let _Module_unify arg = match _Module_unify_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_variant_unify_f : c_obj list -> c_obj list = "_wrap_Module_variant_unifymaude" ;;
let _Module_variant_unify arg = match _Module_variant_unify_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Module_variant_match_f : c_obj list -> c_obj list = "_wrap_Module_variant_matchmaude" ;;
let _Module_variant_match arg = match _Module_variant_match_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _UnificationProblem___next_f : c_obj list -> c_obj list = "_wrap_UnificationProblem___nextmaude" ;;
let _UnificationProblem___next arg = match _UnificationProblem___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_UnificationProblem_f : c_obj list -> c_obj list = "_wrap_delete_UnificationProblemmaude" ;;
let _delete_UnificationProblem arg = match _delete_UnificationProblem_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _VariantUnifierSearch_isIncomplete_f : c_obj list -> c_obj list = "_wrap_VariantUnifierSearch_isIncompletemaude" ;;
let _VariantUnifierSearch_isIncomplete arg = match _VariantUnifierSearch_isIncomplete_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _VariantUnifierSearch_filteringIncomplete_f : c_obj list -> c_obj list = "_wrap_VariantUnifierSearch_filteringIncompletemaude" ;;
let _VariantUnifierSearch_filteringIncomplete arg = match _VariantUnifierSearch_filteringIncomplete_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _VariantUnifierSearch___next_f : c_obj list -> c_obj list = "_wrap_VariantUnifierSearch___nextmaude" ;;
let _VariantUnifierSearch___next arg = match _VariantUnifierSearch___next_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_VariantUnifierSearch_f : c_obj list -> c_obj list = "_wrap_delete_VariantUnifierSearchmaude" ;;
let _delete_VariantUnifierSearch arg = match _delete_VariantUnifierSearch_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _View_getFromTheory_f : c_obj list -> c_obj list = "_wrap_View_getFromTheorymaude" ;;
let _View_getFromTheory arg = match _View_getFromTheory_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _View_getToModule_f : c_obj list -> c_obj list = "_wrap_View_getToModulemaude" ;;
let _View_getToModule arg = match _View_getToModule_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_View_f : c_obj list -> c_obj list = "_wrap_delete_Viewmaude" ;;
let _delete_View arg = match _delete_View_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _HookData_getData_f : c_obj list -> c_obj list = "_wrap_HookData_getDatamaude" ;;
let _HookData_getData arg = match _HookData_getData_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _HookData_getSymbol_f : c_obj list -> c_obj list = "_wrap_HookData_getSymbolmaude" ;;
let _HookData_getSymbol arg = match _HookData_getSymbol_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _HookData_getTerm_f : c_obj list -> c_obj list = "_wrap_HookData_getTermmaude" ;;
let _HookData_getTerm arg = match _HookData_getTerm_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_HookData_f : c_obj list -> c_obj list = "_wrap_delete_HookDatamaude" ;;
let _delete_HookData arg = match _delete_HookData_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _Hook_run_f : c_obj list -> c_obj list = "_wrap_Hook_runmaude" ;;
let _Hook_run arg = match _Hook_run_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _delete_Hook_f : c_obj list -> c_obj list = "_wrap_delete_Hookmaude" ;;
let _delete_Hook arg = match _delete_Hook_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _new_Hook_f : c_obj list -> c_obj list = "_wrap_new_Hookmaude" ;;
let _new_Hook arg = match _new_Hook_f (director_core_helper (fnhelper arg)) with
  [] -> C_void
| [x] -> (if true then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _disown_Hook_f : c_obj list -> c_obj list = "_wrap_disown_Hookmaude" ;;
let _disown_Hook arg = match _disown_Hook_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _connectEqHook_f : c_obj list -> c_obj list = "_wrap_connectEqHookmaude" ;;
let _connectEqHook arg = match _connectEqHook_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external _connectRlHook_f : c_obj list -> c_obj list = "_wrap_connectRlHookmaude" ;;
let _connectRlHook arg = match _connectRlHook_f ((fnhelper arg)) with
  [] -> C_void
| [x] -> (if false then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
external f_init : unit -> unit = "f_maude_init" ;;
let _ = f_init ()
let enum_to_int x (v : c_obj) =
   match v with
     C_enum _y ->
     (let y = _y in match (x : c_enum_type) with
       `unknown ->          (match y with
           `Int x -> (Swig.C_int x)
           | _ -> raise (LabelNotFromThisEnum v))
| `SymbolAttribute -> (match y with
 | `OP_ASSOC -> _OP_ASSOC C_void
 | `OP_COMM -> _OP_COMM C_void
 | `OP_ITER -> _OP_ITER C_void
 | `OP_IDEM -> _OP_IDEM C_void
 | `OP_LEFT_ID -> _OP_LEFT_ID C_void
 | `OP_RIGHT_ID -> _OP_RIGHT_ID C_void
 | `OP_MEMO -> _OP_MEMO C_void
 | `OP_SPECIAL -> _OP_SPECIAL C_void
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
| `TransitionType -> (match y with
 | `RULE_APPLICATION -> _RULE_APPLICATION C_void
 | `OPAQUE_STRATEGY -> _OPAQUE_STRATEGY C_void
 | `SOLUTION -> _SOLUTION C_void
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
| `SearchType -> (match y with
 | `ONE_STEP -> _ONE_STEP C_void
 | `AT_LEAST_ONE_STEP -> _AT_LEAST_ONE_STEP C_void
 | `ANY_STEPS -> _ANY_STEPS C_void
 | `NORMAL_FORM -> _NORMAL_FORM C_void
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
| `PrintFlags -> (match y with
 | `PRINT_CONCEAL -> _PRINT_CONCEAL C_void
 | `PRINT_FORMAT -> _PRINT_FORMAT C_void
 | `PRINT_MIXFIX -> _PRINT_MIXFIX C_void
 | `PRINT_WITH_PARENS -> _PRINT_WITH_PARENS C_void
 | `PRINT_COLOR -> _PRINT_COLOR C_void
 | `PRINT_DISAMBIG_CONST -> _PRINT_DISAMBIG_CONST C_void
 | `PRINT_WITH_ALIASES -> _PRINT_WITH_ALIASES C_void
 | `PRINT_FLAT -> _PRINT_FLAT C_void
 | `PRINT_NUMBER -> _PRINT_NUMBER C_void
 | `PRINT_RAT -> _PRINT_RAT C_void
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
| `ModuleType -> (match y with
 | `FUNCTIONAL_MODULE -> _FUNCTIONAL_MODULE C_void
 | `SYSTEM_MODULE -> _SYSTEM_MODULE C_void
 | `STRATEGY_MODULE -> _STRATEGY_MODULE C_void
 | `FUNCTIONAL_THEORY -> _FUNCTIONAL_THEORY C_void
 | `SYSTEM_THEORY -> _SYSTEM_THEORY C_void
 | `STRATEGY_THEORY -> _STRATEGY_THEORY C_void
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
) | _ -> (C_int (get_int v))
let _ = Callback.register "maude_enum_to_int" enum_to_int
let int_to_enum x y =
    match (x : c_enum_type) with
      `unknown -> C_enum (`Int y)
| `SymbolAttribute -> C_enum (
 if y = (get_int (_OP_ASSOC C_void)) then `OP_ASSOC else
 if y = (get_int (_OP_COMM C_void)) then `OP_COMM else
 if y = (get_int (_OP_ITER C_void)) then `OP_ITER else
 if y = (get_int (_OP_IDEM C_void)) then `OP_IDEM else
 if y = (get_int (_OP_LEFT_ID C_void)) then `OP_LEFT_ID else
 if y = (get_int (_OP_RIGHT_ID C_void)) then `OP_RIGHT_ID else
 if y = (get_int (_OP_MEMO C_void)) then `OP_MEMO else
 if y = (get_int (_OP_SPECIAL C_void)) then `OP_SPECIAL else
`Int y)
| `TransitionType -> C_enum (
 if y = (get_int (_RULE_APPLICATION C_void)) then `RULE_APPLICATION else
 if y = (get_int (_OPAQUE_STRATEGY C_void)) then `OPAQUE_STRATEGY else
 if y = (get_int (_SOLUTION C_void)) then `SOLUTION else
`Int y)
| `SearchType -> C_enum (
 if y = (get_int (_ONE_STEP C_void)) then `ONE_STEP else
 if y = (get_int (_AT_LEAST_ONE_STEP C_void)) then `AT_LEAST_ONE_STEP else
 if y = (get_int (_ANY_STEPS C_void)) then `ANY_STEPS else
 if y = (get_int (_NORMAL_FORM C_void)) then `NORMAL_FORM else
`Int y)
| `PrintFlags -> C_enum (
 if y = (get_int (_PRINT_CONCEAL C_void)) then `PRINT_CONCEAL else
 if y = (get_int (_PRINT_FORMAT C_void)) then `PRINT_FORMAT else
 if y = (get_int (_PRINT_MIXFIX C_void)) then `PRINT_MIXFIX else
 if y = (get_int (_PRINT_WITH_PARENS C_void)) then `PRINT_WITH_PARENS else
 if y = (get_int (_PRINT_COLOR C_void)) then `PRINT_COLOR else
 if y = (get_int (_PRINT_DISAMBIG_CONST C_void)) then `PRINT_DISAMBIG_CONST else
 if y = (get_int (_PRINT_WITH_ALIASES C_void)) then `PRINT_WITH_ALIASES else
 if y = (get_int (_PRINT_FLAT C_void)) then `PRINT_FLAT else
 if y = (get_int (_PRINT_NUMBER C_void)) then `PRINT_NUMBER else
 if y = (get_int (_PRINT_RAT C_void)) then `PRINT_RAT else
`Int y)
| `ModuleType -> C_enum (
 if y = (get_int (_FUNCTIONAL_MODULE C_void)) then `FUNCTIONAL_MODULE else
 if y = (get_int (_SYSTEM_MODULE C_void)) then `SYSTEM_MODULE else
 if y = (get_int (_STRATEGY_MODULE C_void)) then `STRATEGY_MODULE else
 if y = (get_int (_FUNCTIONAL_THEORY C_void)) then `FUNCTIONAL_THEORY else
 if y = (get_int (_SYSTEM_THEORY C_void)) then `SYSTEM_THEORY else
 if y = (get_int (_STRATEGY_THEORY C_void)) then `STRATEGY_THEORY else
`Int y)
let _ = Callback.register "maude_int_to_enum" int_to_enum

let create_std_xxvector_xx_ldbrace_xx_lparenToken_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _TokenVector_size ;
    "empty", _TokenVector_empty ;
    "clear", _TokenVector_clear ;
    "push_back", _TokenVector_push_back ;
    "[]", _TokenVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _TokenVector_operator_xx_xx_equals ;
    "set", _TokenVector_set ;
    "to_array", _TokenVector_to_array ;
    "~", _delete_TokenVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(Token)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(Token)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(Token)>" create_std_xxvector_xx_ldbrace_xx_lparenToken_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< Token >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenToken_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenModuleHeader_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _ModuleHeaderVector_size ;
    "empty", _ModuleHeaderVector_empty ;
    "clear", _ModuleHeaderVector_clear ;
    "push_back", _ModuleHeaderVector_push_back ;
    "[]", _ModuleHeaderVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _ModuleHeaderVector_operator_xx_xx_equals ;
    "set", _ModuleHeaderVector_set ;
    "to_array", _ModuleHeaderVector_to_array ;
    "~", _delete_ModuleHeaderVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(ModuleHeader)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(ModuleHeader)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(ModuleHeader)>" create_std_xxvector_xx_ldbrace_xx_lparenModuleHeader_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< ModuleHeader >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenModuleHeader_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _TermVector_size ;
    "empty", _TermVector_empty ;
    "clear", _TermVector_clear ;
    "push_back", _TermVector_push_back ;
    "[]", _TermVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _TermVector_operator_xx_xx_equals ;
    "set", _TermVector_set ;
    "to_array", _TermVector_to_array ;
    "~", _delete_TermVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(p.EasyTerm)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(p.EasyTerm)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(p.EasyTerm)>" create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< EasyTerm * >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _StringVector_size ;
    "empty", _StringVector_empty ;
    "clear", _StringVector_clear ;
    "push_back", _StringVector_push_back ;
    "[]", _StringVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _StringVector_operator_xx_xx_equals ;
    "set", _StringVector_set ;
    "to_array", _StringVector_to_array ;
    "~", _delete_StringVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(std::string)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(std::string)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(std::string)>" create_std_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< std::string >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "[first]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermPair_first_get args else _TermPair_first_set args) ;
    "[second]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermPair_second_get args else _TermPair_second_set args) ;
    "~", _delete_TermPair ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::pair<(p.EasyTerm,p.EasyTerm)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::pair<(p.EasyTerm,p.EasyTerm)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::pair<(p.EasyTerm,p.EasyTerm)>" create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::pair< EasyTerm *,EasyTerm * >_from_ptr"
          create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenstd_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _TermPairVector_size ;
    "empty", _TermPairVector_empty ;
    "clear", _TermPairVector_clear ;
    "push_back", _TermPairVector_push_back ;
    "[]", _TermPairVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _TermPairVector_operator_xx_xx_equals ;
    "set", _TermPairVector_set ;
    "to_array", _TermPairVector_to_array ;
    "~", _delete_TermPairVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(std::pair<(p.EasyTerm,p.EasyTerm)>)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(std::pair<(p.EasyTerm,p.EasyTerm)>)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(std::pair<(p.EasyTerm,p.EasyTerm)>)>" create_std_xxvector_xx_ldbrace_xx_lparenstd_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< std::pair< EasyTerm *,EasyTerm * > >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenstd_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasyTerm_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotView_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _ViewVector_size ;
    "empty", _ViewVector_empty ;
    "clear", _ViewVector_clear ;
    "push_back", _ViewVector_push_back ;
    "[]", _ViewVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _ViewVector_operator_xx_xx_equals ;
    "set", _ViewVector_set ;
    "to_array", _ViewVector_to_array ;
    "~", _delete_ViewVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(p.View)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(p.View)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(p.View)>" create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotView_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< View * >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenp_xx_dotView_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenint_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _IntVector_size ;
    "empty", _IntVector_empty ;
    "clear", _IntVector_clear ;
    "push_back", _IntVector_push_back ;
    "[]", _IntVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _IntVector_operator_xx_xx_equals ;
    "set", _IntVector_set ;
    "to_array", _IntVector_to_array ;
    "~", _delete_IntVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(int)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(int)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(int)>" create_std_xxvector_xx_ldbrace_xx_lparenint_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< int >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenint_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xint_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "[first]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermIntPair_first_get args else _TermIntPair_first_set args) ;
    "[second]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermIntPair_second_get args else _TermIntPair_second_set args) ;
    "~", _delete_TermIntPair ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::pair<(p.EasyTerm,int)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::pair<(p.EasyTerm,int)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::pair<(p.EasyTerm,int)>" create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xint_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::pair< EasyTerm *,int >_from_ptr"
          create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xint_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasySubstitution_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "[first]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermSubstitutionPair_first_get args else _TermSubstitutionPair_first_set args) ;
    "[second]", (fun args -> if args = (C_list [ raw_ptr ]) then _TermSubstitutionPair_second_get args else _TermSubstitutionPair_second_set args) ;
    "~", _delete_TermSubstitutionPair ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::pair<(p.EasyTerm,p.EasySubstitution)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::pair<(p.EasyTerm,p.EasySubstitution)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::pair<(p.EasyTerm,p.EasySubstitution)>" create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasySubstitution_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::pair< EasyTerm *,EasySubstitution * >_from_ptr"
          create_std_xxpair_xx_ldbrace_xx_lparenp_xx_dotEasyTerm_xp_xx_dotEasySubstitution_xx_rparen_xx_rdbrace_from_ptr



let create_std_xxvector_xx_ldbrace_xx_lparenstd_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _StringVectorVector_size ;
    "empty", _StringVectorVector_empty ;
    "clear", _StringVectorVector_clear ;
    "push_back", _StringVectorVector_push_back ;
    "[]", _StringVectorVector_operator_xx_xx_lbrace_xx_rbrace ;
    "=", _StringVectorVector_operator_xx_xx_equals ;
    "set", _StringVectorVector_set ;
    "to_array", _StringVectorVector_to_array ;
    "~", _delete_StringVectorVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "std::vector<(std::vector<(std::string)>)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"std::vector<(std::vector<(std::string)>)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "std::vector<(std::vector<(std::string)>)>" create_std_xxvector_xx_ldbrace_xx_lparenstd_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_std::vector< std::vector< std::string > >_from_ptr"
          create_std_xxvector_xx_ldbrace_xx_lparenstd_xxvector_xx_ldbrace_xx_lparenstd_xxstring_xx_rparen_xx_rdbrace_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotq_xx_lparenconst_xx_rparen_xx_dotOpDeclaration_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _OpDeclVector_empty ;
    "size", _OpDeclVector_size ;
    "capacity", _OpDeclVector_capacity ;
    "swap", _OpDeclVector_swap ;
    "__getitem__", _OpDeclVector___getitem__ ;
    "__setitem__", _OpDeclVector___setitem__ ;
    "append", _OpDeclVector_append ;
    "clear", _OpDeclVector_clear ;
    "resize", _OpDeclVector_resize ;
    "~", _delete_OpDeclVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.q(const).OpDeclaration)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.q(const).OpDeclaration)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.q(const).OpDeclaration)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotq_xx_lparenconst_xx_rparen_xx_dotOpDeclaration_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< OpDeclaration const * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotq_xx_lparenconst_xx_rparen_xx_dotOpDeclaration_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotSort_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _SortVector_empty ;
    "size", _SortVector_size ;
    "capacity", _SortVector_capacity ;
    "swap", _SortVector_swap ;
    "__getitem__", _SortVector___getitem__ ;
    "__setitem__", _SortVector___setitem__ ;
    "append", _SortVector_append ;
    "clear", _SortVector_clear ;
    "resize", _SortVector_resize ;
    "~", _delete_SortVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.Sort)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.Sort)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.Sort)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotSort_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< Sort * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotSort_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotSymbol_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _SymbolVector_empty ;
    "size", _SymbolVector_size ;
    "capacity", _SymbolVector_capacity ;
    "swap", _SymbolVector_swap ;
    "__getitem__", _SymbolVector___getitem__ ;
    "__setitem__", _SymbolVector___setitem__ ;
    "append", _SymbolVector_append ;
    "clear", _SymbolVector_clear ;
    "resize", _SymbolVector_resize ;
    "~", _delete_SymbolVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.Symbol)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.Symbol)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.Symbol)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotSymbol_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< Symbol * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotSymbol_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotConnectedComponent_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _KindVector_empty ;
    "size", _KindVector_size ;
    "capacity", _KindVector_capacity ;
    "swap", _KindVector_swap ;
    "__getitem__", _KindVector___getitem__ ;
    "__setitem__", _KindVector___setitem__ ;
    "append", _KindVector_append ;
    "clear", _KindVector_clear ;
    "resize", _KindVector_resize ;
    "~", _delete_KindVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.ConnectedComponent)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.ConnectedComponent)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.ConnectedComponent)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotConnectedComponent_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< ConnectedComponent * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotConnectedComponent_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotSortConstraint_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _SubsortVector_empty ;
    "size", _SubsortVector_size ;
    "capacity", _SubsortVector_capacity ;
    "swap", _SubsortVector_swap ;
    "__getitem__", _SubsortVector___getitem__ ;
    "__setitem__", _SubsortVector___setitem__ ;
    "append", _SubsortVector_append ;
    "clear", _SubsortVector_clear ;
    "resize", _SubsortVector_resize ;
    "~", _delete_SubsortVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.SortConstraint)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.SortConstraint)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.SortConstraint)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotSortConstraint_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< SortConstraint * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotSortConstraint_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotEquation_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _EquationVector_empty ;
    "size", _EquationVector_size ;
    "capacity", _EquationVector_capacity ;
    "swap", _EquationVector_swap ;
    "__getitem__", _EquationVector___getitem__ ;
    "__setitem__", _EquationVector___setitem__ ;
    "append", _EquationVector_append ;
    "clear", _EquationVector_clear ;
    "resize", _EquationVector_resize ;
    "~", _delete_EquationVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.Equation)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.Equation)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.Equation)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotEquation_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< Equation * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotEquation_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotRule_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _RuleVector_empty ;
    "size", _RuleVector_size ;
    "capacity", _RuleVector_capacity ;
    "swap", _RuleVector_swap ;
    "__getitem__", _RuleVector___getitem__ ;
    "__setitem__", _RuleVector___setitem__ ;
    "append", _RuleVector_append ;
    "clear", _RuleVector_clear ;
    "resize", _RuleVector_resize ;
    "~", _delete_RuleVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.Rule)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.Rule)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.Rule)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotRule_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< Rule * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotRule_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotRewriteStrategy_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _StratVector_empty ;
    "size", _StratVector_size ;
    "capacity", _StratVector_capacity ;
    "swap", _StratVector_swap ;
    "__getitem__", _StratVector___getitem__ ;
    "__setitem__", _StratVector___setitem__ ;
    "append", _StratVector_append ;
    "clear", _StratVector_clear ;
    "resize", _StratVector_resize ;
    "~", _delete_StratVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.RewriteStrategy)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.RewriteStrategy)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.RewriteStrategy)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotRewriteStrategy_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< RewriteStrategy * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotRewriteStrategy_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotStrategyDefinition_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _StratDefVector_empty ;
    "size", _StratDefVector_size ;
    "capacity", _StratDefVector_capacity ;
    "swap", _StratDefVector_swap ;
    "__getitem__", _StratDefVector___getitem__ ;
    "__setitem__", _StratDefVector___setitem__ ;
    "append", _StratDefVector_append ;
    "clear", _StratDefVector_clear ;
    "resize", _StratDefVector_resize ;
    "~", _delete_StratDefVector ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.StrategyDefinition)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.StrategyDefinition)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.StrategyDefinition)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotStrategyDefinition_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< StrategyDefinition * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotStrategyDefinition_xx_rparen_xx_rdbrace_from_ptr



let create_Vector_xx_ldbrace_xx_lparenp_xx_dotConditionFragment_xx_rparen_xx_rdbrace_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "empty", _Condition_empty ;
    "size", _Condition_size ;
    "capacity", _Condition_capacity ;
    "swap", _Condition_swap ;
    "__getitem__", _Condition___getitem__ ;
    "__setitem__", _Condition___setitem__ ;
    "append", _Condition_append ;
    "clear", _Condition_clear ;
    "resize", _Condition_resize ;
    "~", _delete_Condition ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Vector<(p.ConditionFragment)>") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Vector<(p.ConditionFragment)>"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Vector<(p.ConditionFragment)>" create_Vector_xx_ldbrace_xx_lparenp_xx_dotConditionFragment_xx_rparen_xx_rdbrace_from_ptr
let _ = Callback.register 
          "create_Vector< ConditionFragment * >_from_ptr"
          create_Vector_xx_ldbrace_xx_lparenp_xx_dotConditionFragment_xx_rparen_xx_rdbrace_from_ptr



let create_ModuleHeader_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "[type]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModuleHeader_type_get args else C_void) ;
    "[name]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModuleHeader_name_get args else C_void) ;
    "~", _delete_ModuleHeader ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "ModuleHeader") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"ModuleHeader"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "ModuleHeader" create_ModuleHeader_from_ptr
let _ = Callback.register 
          "create_ModuleHeader_from_ptr"
          create_ModuleHeader_from_ptr



let create_ModuleItem_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getModule", _ModuleItem_getModule ;
    "~", _delete_ModuleItem ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "ModuleItem") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"ModuleItem"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "ModuleItem" create_ModuleItem_from_ptr
let _ = Callback.register 
          "create_ModuleItem_from_ptr"
          create_ModuleItem_from_ptr



let create_Equation_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _Equation_getLhs ;
    "getRhs", _Equation_getRhs ;
    "getLabel", _Equation_getLabel ;
    "isNonexec", _Equation_isNonexec ;
    "isOwise", _Equation_isOwise ;
    "isVariant", _Equation_isVariant ;
    "hasCondition", _Equation_hasCondition ;
    "getCondition", _Equation_getCondition ;
    "getMetadata", _Equation_getMetadata ;
    "getLineNumber", _Equation_getLineNumber ;
    "hash", _Equation_hash ;
    "equal", _Equation_equal ;
    "~", _delete_Equation ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Equation") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Equation"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Equation" create_Equation_from_ptr
let _ = Callback.register 
          "create_Equation_from_ptr"
          create_Equation_from_ptr



let create_Sort_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "kind", _Sort_kind ;
    "getSubsorts", _Sort_getSubsorts ;
    "getSupersorts", _Sort_getSupersorts ;
    "leq", _Sort_leq ;
    "getLineNumber", _Sort_getLineNumber ;
    "hash", _Sort_hash ;
    "equal", _Sort_equal ;
    "~", _delete_Sort ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Sort") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Sort"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Sort" create_Sort_from_ptr
let _ = Callback.register 
          "create_Sort_from_ptr"
          create_Sort_from_ptr



let create_ConnectedComponent_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "nrSorts", _Kind_nrSorts ;
    "nrMaximalSorts", _Kind_nrMaximalSorts ;
    "sort", _Kind_sort ;
    "errorFree", _Kind_errorFree ;
    "hash", _Kind_hash ;
    "equal", _Kind_equal ;
    "~", _delete_Kind ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "ConnectedComponent") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"ConnectedComponent"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "ConnectedComponent" create_ConnectedComponent_from_ptr
let _ = Callback.register 
          "create_ConnectedComponent_from_ptr"
          create_ConnectedComponent_from_ptr



let create_SortConstraint_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _MembershipAxiom_getLhs ;
    "getSort", _MembershipAxiom_getSort ;
    "getCondition", _MembershipAxiom_getCondition ;
    "isNonexec", _MembershipAxiom_isNonexec ;
    "getLabel", _MembershipAxiom_getLabel ;
    "getMetadata", _MembershipAxiom_getMetadata ;
    "getLineNumber", _MembershipAxiom_getLineNumber ;
    "hash", _MembershipAxiom_hash ;
    "equal", _MembershipAxiom_equal ;
    "~", _delete_MembershipAxiom ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "SortConstraint") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"SortConstraint"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "SortConstraint" create_SortConstraint_from_ptr
let _ = Callback.register 
          "create_SortConstraint_from_ptr"
          create_SortConstraint_from_ptr



let create_Symbol_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "arity", _Symbol_arity ;
    "domainKind", _Symbol_domainKind ;
    "getRangeSort", _Symbol_getRangeSort ;
    "hash", _Symbol_hash ;
    "equal", _Symbol_equal ;
    "getOpDeclarations", _Symbol_getOpDeclarations ;
    "makeTerm", _Symbol_makeTerm ;
    "getMetadata", _Symbol_getMetadata ;
    "isAssoc", _Symbol_isAssoc ;
    "hasAttr", _Symbol_hasAttr ;
    "getIdentity", _Symbol_getIdentity ;
    "getStrategy", _Symbol_getStrategy ;
    "getFrozen", _Symbol_getFrozen ;
    "getFormat", _Symbol_getFormat ;
    "getPrec", _Symbol_getPrec ;
    "getIdHooks", _Symbol_getIdHooks ;
    "getLineNumber", _Symbol_getLineNumber ;
    "~", _delete_Symbol ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Symbol") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Symbol"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Symbol" create_Symbol_from_ptr
let _ = Callback.register 
          "create_Symbol_from_ptr"
          create_Symbol_from_ptr



let create_OpDeclaration_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getDomainAndRange", _OpDeclaration_getDomainAndRange ;
    "isConstructor", _OpDeclaration_isConstructor ;
    "~", _delete_OpDeclaration ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "OpDeclaration") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"OpDeclaration"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "OpDeclaration" create_OpDeclaration_from_ptr
let _ = Callback.register 
          "create_OpDeclaration_from_ptr"
          create_OpDeclaration_from_ptr



let create_Rule_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _Rule_getLhs ;
    "getRhs", _Rule_getRhs ;
    "getLabel", _Rule_getLabel ;
    "isNarrowing", _Rule_isNarrowing ;
    "isNonexec", _Rule_isNonexec ;
    "hasCondition", _Rule_hasCondition ;
    "getCondition", _Rule_getCondition ;
    "getMetadata", _Rule_getMetadata ;
    "getLineNumber", _Rule_getLineNumber ;
    "hash", _Rule_hash ;
    "equal", _Rule_equal ;
    "~", _delete_Rule ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Rule") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Rule"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Rule" create_Rule_from_ptr
let _ = Callback.register 
          "create_Rule_from_ptr"
          create_Rule_from_ptr



let create_StrategyExpression_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "~", _delete_StrategyExpression ;
    "equal", _StrategyExpression_equal ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategyExpression") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategyExpression"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategyExpression" create_StrategyExpression_from_ptr
let _ = Callback.register 
          "create_StrategyExpression_from_ptr"
          create_StrategyExpression_from_ptr



let create_RewriteStrategy_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getDomain", _RewriteStrategy_getDomain ;
    "getSubjectSort", _RewriteStrategy_getSubjectSort ;
    "getDefinitions", _RewriteStrategy_getDefinitions ;
    "arity", _RewriteStrategy_arity ;
    "getName", _RewriteStrategy_getName ;
    "getMetadata", _RewriteStrategy_getMetadata ;
    "getLineNumber", _RewriteStrategy_getLineNumber ;
    "hash", _RewriteStrategy_hash ;
    "equal", _RewriteStrategy_equal ;
    "~", _delete_RewriteStrategy ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "RewriteStrategy") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"RewriteStrategy"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "RewriteStrategy" create_RewriteStrategy_from_ptr
let _ = Callback.register 
          "create_RewriteStrategy_from_ptr"
          create_RewriteStrategy_from_ptr



let create_StrategyDefinition_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _StrategyDefinition_getLhs ;
    "getRhs", _StrategyDefinition_getRhs ;
    "getStrategy", _StrategyDefinition_getStrategy ;
    "isNonexec", _StrategyDefinition_isNonexec ;
    "hasCondition", _StrategyDefinition_hasCondition ;
    "getCondition", _StrategyDefinition_getCondition ;
    "getLabel", _StrategyDefinition_getLabel ;
    "getMetadata", _StrategyDefinition_getMetadata ;
    "getLineNumber", _StrategyDefinition_getLineNumber ;
    "hash", _StrategyDefinition_hash ;
    "equal", _StrategyDefinition_equal ;
    "~", _delete_StrategyDefinition ;
   "::ModuleItem", (fun args -> (create_class "ModuleItem") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategyDefinition") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ModuleItem") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategyDefinition"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategyDefinition" create_StrategyDefinition_from_ptr
let _ = Callback.register 
          "create_StrategyDefinition_from_ptr"
          create_StrategyDefinition_from_ptr



let create_Token_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "name", _Token_name ;
    "REPR_METHOD", _Token_REPR_METHOD ;
    "~", _delete_Token ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Token") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Token"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Token" create_Token_from_ptr
let _ = Callback.register 
          "create_Token_from_ptr"
          create_Token_from_ptr



let create_ConditionFragment_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "~", _delete_ConditionFragment ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "ConditionFragment") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"ConditionFragment"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "ConditionFragment" create_ConditionFragment_from_ptr
let _ = Callback.register 
          "create_ConditionFragment_from_ptr"
          create_ConditionFragment_from_ptr



let create_EqualityConditionFragment_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _EqualityCondition_getLhs ;
    "getRhs", _EqualityCondition_getRhs ;
    "~", _delete_EqualityCondition ;
   "::ConditionFragment", (fun args -> (create_class "ConditionFragment") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "EqualityConditionFragment") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ConditionFragment") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"EqualityConditionFragment"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "EqualityConditionFragment" create_EqualityConditionFragment_from_ptr
let _ = Callback.register 
          "create_EqualityConditionFragment_from_ptr"
          create_EqualityConditionFragment_from_ptr



let create_AssignmentConditionFragment_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _AssignmentCondition_getLhs ;
    "getRhs", _AssignmentCondition_getRhs ;
    "~", _delete_AssignmentCondition ;
   "::ConditionFragment", (fun args -> (create_class "ConditionFragment") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "AssignmentConditionFragment") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ConditionFragment") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"AssignmentConditionFragment"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "AssignmentConditionFragment" create_AssignmentConditionFragment_from_ptr
let _ = Callback.register 
          "create_AssignmentConditionFragment_from_ptr"
          create_AssignmentConditionFragment_from_ptr



let create_RewriteConditionFragment_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _RewriteCondition_getLhs ;
    "getRhs", _RewriteCondition_getRhs ;
    "~", _delete_RewriteCondition ;
   "::ConditionFragment", (fun args -> (create_class "ConditionFragment") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "RewriteConditionFragment") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ConditionFragment") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"RewriteConditionFragment"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "RewriteConditionFragment" create_RewriteConditionFragment_from_ptr
let _ = Callback.register 
          "create_RewriteConditionFragment_from_ptr"
          create_RewriteConditionFragment_from_ptr



let create_SortTestConditionFragment_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getLhs", _SortTestCondition_getLhs ;
    "getSort", _SortTestCondition_getSort ;
    "~", _delete_SortTestCondition ;
   "::ConditionFragment", (fun args -> (create_class "ConditionFragment") args) ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "SortTestConditionFragment") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    (create_class "ConditionFragment") ;

		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"SortTestConditionFragment"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "SortTestConditionFragment" create_SortTestConditionFragment_from_ptr
let _ = Callback.register 
          "create_SortTestConditionFragment_from_ptr"
          create_SortTestConditionFragment_from_ptr



let create_ModelCheckResult_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "[holds]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModelCheckResult_holds_get args else C_void) ;
    "[leadIn]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModelCheckResult_leadIn_get args else C_void) ;
    "[cycle]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModelCheckResult_cycle_get args else C_void) ;
    "[nrBuchiStates]", (fun args -> if args = (C_list [ raw_ptr ]) then _ModelCheckResult_nrBuchiStates_get args else C_void) ;
    "~", _delete_ModelCheckResult ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "ModelCheckResult") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"ModelCheckResult"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "ModelCheckResult" create_ModelCheckResult_from_ptr
let _ = Callback.register 
          "create_ModelCheckResult_from_ptr"
          create_ModelCheckResult_from_ptr



let create_StateTransitionGraph_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getStateTerm", _RewriteGraph_getStateTerm ;
    "getRule", _RewriteGraph_getRule ;
    "getNrRewrites", _RewriteGraph_getNrRewrites ;
    "modelCheck", _RewriteGraph_modelCheck ;
    "getNrStates", _RewriteGraph_getNrStates ;
    "getNextState", _RewriteGraph_getNextState ;
    "getStateParent", _RewriteGraph_getStateParent ;
    "~", _delete_RewriteGraph ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StateTransitionGraph") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StateTransitionGraph"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StateTransitionGraph" create_StateTransitionGraph_from_ptr
let _ = Callback.register 
          "create_StateTransitionGraph_from_ptr"
          create_StateTransitionGraph_from_ptr



let create_StrategyTransitionGraph_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getStateTerm", _StrategyRewriteGraph_getStateTerm ;
    "getStateStrategy", _StrategyRewriteGraph_getStateStrategy ;
    "getTransition", _StrategyRewriteGraph_getTransition ;
    "getNrRewrites", _StrategyRewriteGraph_getNrRewrites ;
    "modelCheck", _StrategyRewriteGraph_modelCheck ;
    "getNrStates", _StrategyRewriteGraph_getNrStates ;
    "getNrRealStates", _StrategyRewriteGraph_getNrRealStates ;
    "getNextState", _StrategyRewriteGraph_getNextState ;
    "isSolutionState", _StrategyRewriteGraph_isSolutionState ;
    "~", _delete_StrategyRewriteGraph ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategyTransitionGraph") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategyTransitionGraph"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategyTransitionGraph" create_StrategyTransitionGraph_from_ptr
let _ = Callback.register 
          "create_StrategyTransitionGraph_from_ptr"
          create_StrategyTransitionGraph_from_ptr



let create_StrategyTransitionGraph_xxTransition_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getType", _StrategyGraphTransition_getType ;
    "getRule", _StrategyGraphTransition_getRule ;
    "getStrategy", _StrategyGraphTransition_getStrategy ;
    "REPR_METHOD", _StrategyGraphTransition_REPR_METHOD ;
    "~", _delete_StrategyGraphTransition ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategyTransitionGraph::Transition") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategyTransitionGraph::Transition"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategyTransitionGraph::Transition" create_StrategyTransitionGraph_xxTransition_from_ptr
let _ = Callback.register 
          "create_StrategyTransitionGraph::Transition_from_ptr"
          create_StrategyTransitionGraph_xxTransition_from_ptr



let create_EasyTerm_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "~", _delete_Term ;
    "symbol", _Term_symbol ;
    "ground", _Term_ground ;
    "equal", _Term_equal ;
    "leq", _Term_leq ;
    "getSort", _Term_getSort ;
    "reduce", _Term_reduce ;
    "rewrite", _Term_rewrite ;
    "frewrite", _Term_frewrite ;
    "erewrite", _Term_erewrite ;
    "match", _Term_match ;
    "srewrite", _Term_srewrite ;
    "search", _Term_search ;
    "get_variants", _Term_get_variants ;
    "vu_narrow", _Term_vu_narrow ;
    "apply", _Term_apply ;
    "check", _Term_check ;
    "arguments", _Term_arguments ;
    "toFloat", _Term_toFloat ;
    "toInt", _Term_toInt ;
    "isVariable", _Term_isVariable ;
    "getVarName", _Term_getVarName ;
    "getIterExponent", _Term_getIterExponent ;
    "hash", _Term_hash ;
    "copy", _Term_copy ;
    "prettyPrint", _Term_prettyPrint ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "EasyTerm") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"EasyTerm"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "EasyTerm" create_EasyTerm_from_ptr
let _ = Callback.register 
          "create_EasyTerm_from_ptr"
          create_EasyTerm_from_ptr



let create_StrategicSearch_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getRewriteCount", _StrategicSearch_getRewriteCount ;
    "__next", _StrategicSearch___next ;
    "~", _delete_StrategicSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategicSearch") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategicSearch"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategicSearch" create_StrategicSearch_from_ptr
let _ = Callback.register 
          "create_StrategicSearch_from_ptr"
          create_StrategicSearch_from_ptr



let create_EasySubstitution_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "size", _Substitution_size ;
    "value", _Substitution_value ;
    "matchedPortion", _Substitution_matchedPortion ;
    "find", _Substitution_find ;
    "instantiate", _Substitution_instantiate ;
    "iterator", _Substitution_iterator ;
    "~", _delete_Substitution ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "EasySubstitution") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"EasySubstitution"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "EasySubstitution" create_EasySubstitution_from_ptr
let _ = Callback.register 
          "create_EasySubstitution_from_ptr"
          create_EasySubstitution_from_ptr



let create_EasySubstitution_xxIterator_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "nextAssignment", _Iterator_nextAssignment ;
    "getVariable", _Iterator_getVariable ;
    "getValue", _Iterator_getValue ;
    "~", _delete_Iterator ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "EasySubstitution::Iterator") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"EasySubstitution::Iterator"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "EasySubstitution::Iterator" create_EasySubstitution_xxIterator_from_ptr
let _ = Callback.register 
          "create_EasySubstitution::Iterator_from_ptr"
          create_EasySubstitution_xxIterator_from_ptr



let create_MatchSearchState_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "__next", _MatchSearchState___next ;
    "fillContext", _MatchSearchState_fillContext ;
    "~", _delete_MatchSearchState ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "MatchSearchState") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"MatchSearchState"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "MatchSearchState" create_MatchSearchState_from_ptr
let _ = Callback.register 
          "create_MatchSearchState_from_ptr"
          create_MatchSearchState_from_ptr



let create_RewriteSequenceSearch_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getRewriteCount", _RewriteSequenceSearch_getRewriteCount ;
    "getSubstitution", _RewriteSequenceSearch_getSubstitution ;
    "getRule", _RewriteSequenceSearch_getRule ;
    "getStateTerm", _RewriteSequenceSearch_getStateTerm ;
    "__next", _RewriteSequenceSearch___next ;
    "getStateNr", _RewriteSequenceSearch_getStateNr ;
    "getStateParent", _RewriteSequenceSearch_getStateParent ;
    "~", _delete_RewriteSequenceSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "RewriteSequenceSearch") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"RewriteSequenceSearch"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "RewriteSequenceSearch" create_RewriteSequenceSearch_from_ptr
let _ = Callback.register 
          "create_RewriteSequenceSearch_from_ptr"
          create_RewriteSequenceSearch_from_ptr



let create_StrategySequenceSearch_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getRewriteCount", _StrategySequenceSearch_getRewriteCount ;
    "getSubstitution", _StrategySequenceSearch_getSubstitution ;
    "getTransition", _StrategySequenceSearch_getTransition ;
    "getStateTerm", _StrategySequenceSearch_getStateTerm ;
    "getStrategyContinuation", _StrategySequenceSearch_getStrategyContinuation ;
    "__next", _StrategySequenceSearch___next ;
    "getStateNr", _StrategySequenceSearch_getStateNr ;
    "getStateParent", _StrategySequenceSearch_getStateParent ;
    "~", _delete_StrategySequenceSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "StrategySequenceSearch") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"StrategySequenceSearch"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "StrategySequenceSearch" create_StrategySequenceSearch_from_ptr
let _ = Callback.register 
          "create_StrategySequenceSearch_from_ptr"
          create_StrategySequenceSearch_from_ptr



let create_NarrowingSequenceSearch3_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "isIncomplete", _NarrowingSequenceSearch_isIncomplete ;
    "__next", _NarrowingSequenceSearch___next ;
    "getSubstitution", _NarrowingSequenceSearch_getSubstitution ;
    "getUnifier", _NarrowingSequenceSearch_getUnifier ;
    "~", _delete_NarrowingSequenceSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "NarrowingSequenceSearch3") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"NarrowingSequenceSearch3"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "NarrowingSequenceSearch3" create_NarrowingSequenceSearch3_from_ptr
let _ = Callback.register 
          "create_NarrowingSequenceSearch3_from_ptr"
          create_NarrowingSequenceSearch3_from_ptr



let create_VariantSearch_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "isIncomplete", _VariantSearch_isIncomplete ;
    "__next", _VariantSearch___next ;
    "~", _delete_VariantSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "VariantSearch") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"VariantSearch"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "VariantSearch" create_VariantSearch_from_ptr
let _ = Callback.register 
          "create_VariantSearch_from_ptr"
          create_VariantSearch_from_ptr



let create_RewriteSearchState_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getRule", _RewriteSearchState_getRule ;
    "__next", _RewriteSearchState___next ;
    "getSubstitution", _RewriteSearchState_getSubstitution ;
    "fillContext", _RewriteSearchState_fillContext ;
    "~", _delete_RewriteSearchState ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "RewriteSearchState") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"RewriteSearchState"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "RewriteSearchState" create_RewriteSearchState_from_ptr
let _ = Callback.register 
          "create_RewriteSearchState_from_ptr"
          create_RewriteSearchState_from_ptr



let create_DagArgumentIterator_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "valid", _ArgumentIterator_valid ;
    "__next", _ArgumentIterator___next ;
    "argument", _ArgumentIterator_argument ;
    "~", _delete_ArgumentIterator ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "DagArgumentIterator") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"DagArgumentIterator"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "DagArgumentIterator" create_DagArgumentIterator_from_ptr
let _ = Callback.register 
          "create_DagArgumentIterator_from_ptr"
          create_DagArgumentIterator_from_ptr



let create_VisibleModule_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "~", _delete_Module ;
    "getModuleType", _Module_getModuleType ;
    "getSorts", _Module_getSorts ;
    "getSymbols", _Module_getSymbols ;
    "getKinds", _Module_getKinds ;
    "getMembershipAxioms", _Module_getMembershipAxioms ;
    "getEquations", _Module_getEquations ;
    "getRules", _Module_getRules ;
    "getStrategies", _Module_getStrategies ;
    "getStrategyDefinitions", _Module_getStrategyDefinitions ;
    "getNrParameters", _Module_getNrParameters ;
    "hasFreeParameters", _Module_hasFreeParameters ;
    "getNrImportedSorts", _Module_getNrImportedSorts ;
    "getNrImportedSymbols", _Module_getNrImportedSymbols ;
    "getNrImportedStrategies", _Module_getNrImportedStrategies ;
    "getNrOriginalEquations", _Module_getNrOriginalEquations ;
    "getNrOriginalRules", _Module_getNrOriginalRules ;
    "getNrOriginalStrategyDefinitions", _Module_getNrOriginalStrategyDefinitions ;
    "getParameterTheory", _Module_getParameterTheory ;
    "getParameterName", _Module_getParameterName ;
    "findSort", _Module_findSort ;
    "findSymbol", _Module_findSymbol ;
    "parseTerm", _Module_parseTerm ;
    "parseStrategy", _Module_parseStrategy ;
    "downTerm", _Module_downTerm ;
    "downStrategy", _Module_downStrategy ;
    "upTerm", _Module_upTerm ;
    "upStrategy", _Module_upStrategy ;
    "unify", _Module_unify ;
    "variant_unify", _Module_variant_unify ;
    "variant_match", _Module_variant_match ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "VisibleModule") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"VisibleModule"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "VisibleModule" create_VisibleModule_from_ptr
let _ = Callback.register 
          "create_VisibleModule_from_ptr"
          create_VisibleModule_from_ptr



let create_UnificationProblem_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "__next", _UnificationProblem___next ;
    "~", _delete_UnificationProblem ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "UnificationProblem") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"UnificationProblem"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "UnificationProblem" create_UnificationProblem_from_ptr
let _ = Callback.register 
          "create_UnificationProblem_from_ptr"
          create_UnificationProblem_from_ptr



let create_VariantUnifierSearch_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "isIncomplete", _VariantUnifierSearch_isIncomplete ;
    "filteringIncomplete", _VariantUnifierSearch_filteringIncomplete ;
    "__next", _VariantUnifierSearch___next ;
    "~", _delete_VariantUnifierSearch ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "VariantUnifierSearch") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"VariantUnifierSearch"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "VariantUnifierSearch" create_VariantUnifierSearch_from_ptr
let _ = Callback.register 
          "create_VariantUnifierSearch_from_ptr"
          create_VariantUnifierSearch_from_ptr



let create_View_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getFromTheory", _View_getFromTheory ;
    "getToModule", _View_getToModule ;
    "~", _delete_View ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "View") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"View"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "View" create_View_from_ptr
let _ = Callback.register 
          "create_View_from_ptr"
          create_View_from_ptr



let create_HookData_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "getData", _HookData_getData ;
    "getSymbol", _HookData_getSymbol ;
    "getTerm", _HookData_getTerm ;
    "~", _delete_HookData ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "HookData") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"HookData"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "HookData" create_HookData_from_ptr
let _ = Callback.register 
          "create_HookData_from_ptr"
          create_HookData_from_ptr



let create_Hook_from_ptr raw_ptr =
  C_obj 
begin
  let h = Hashtbl.create 20 in
    List.iter (fun (nm,fn) -> Hashtbl.replace h nm fn) 
	[ "nop", (fun args -> C_void) ;
	      "run", _Hook_run ;
    "~", _delete_Hook ;
    "", _disown_Hook ;
 
	 "&", (fun args -> raw_ptr) ;
       ":parents",
       (fun args ->
          C_list
	  (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (x,y) :: !out) h ;
          (List.map	
	     (fun (x,y) ->
		C_string (String.sub x 2 ((String.length x) - 2)))
	     (List.filter
		(fun (x,y) ->
		   ((String.length x) > 2)
		   && x.[0] == ':' && x.[1] == ':') !out)))) ;
       ":classof", (fun args -> C_string "Hook") ;
       ":methods", (fun args -> 
	  C_list (let out = ref [] in 
	    Hashtbl.iter (fun x y -> out := (C_string x) :: !out) h ; !out))
	] ; 
	let rec invoke_inner raw_ptr mth arg = 
	begin
	  try
	    let application = Hashtbl.find h mth in
	      application
		(match arg with 
		     C_list l -> (C_list (raw_ptr :: l)) 
		   | C_void -> (C_list [ raw_ptr ])
		   | v -> (C_list [ raw_ptr ; v ]))
	  with Not_found -> 
		(* Try parent classes *)
		begin
		  let parent_classes = [
		    
		  ] in
		  let rec try_parent plist raw_ptr =
		    match plist with
			p :: tl -> 
			  begin
			    try
			      (invoke (p raw_ptr)) mth arg
			    with (BadMethodName (p,m,s)) -> 
			      try_parent tl raw_ptr
			  end
		      | [] ->
			  raise (BadMethodName (raw_ptr,mth,"Hook"))
		  in try_parent parent_classes raw_ptr
		end
	end in
	  (fun mth arg -> invoke_inner raw_ptr mth arg)
end

let _ = register_class_byname "Hook" create_Hook_from_ptr
let _ = Callback.register 
          "create_Hook_from_ptr"
          create_Hook_from_ptr


let new_TokenVector clst = _new_TokenVector clst
let new_ModuleHeaderVector clst = _new_ModuleHeaderVector clst
let new_TermVector clst = _new_TermVector clst
let new_StringVector clst = _new_StringVector clst
let new_TermPair clst = _new_TermPair clst
let new_TermPairVector clst = _new_TermPairVector clst
let new_ViewVector clst = _new_ViewVector clst
let new_IntVector clst = _new_IntVector clst
let new_TermIntPair clst = _new_TermIntPair clst
let new_TermSubstitutionPair clst = _new_TermSubstitutionPair clst
let new_StringVectorVector clst = _new_StringVectorVector clst
let new_OpDeclVector clst = _new_OpDeclVector clst
let new_SortVector clst = _new_SortVector clst
let new_SymbolVector clst = _new_SymbolVector clst
let new_KindVector clst = _new_KindVector clst
let new_SubsortVector clst = _new_SubsortVector clst
let new_EquationVector clst = _new_EquationVector clst
let new_RuleVector clst = _new_RuleVector clst
let new_StratVector clst = _new_StratVector clst
let new_StratDefVector clst = _new_StratDefVector clst
let new_Condition clst = _new_Condition clst
let new_ModuleHeader clst = _new_ModuleHeader clst
let new_OpDeclaration clst = _new_OpDeclaration clst
let new_Token clst = _new_Token clst
let new_EqualityCondition clst = _new_EqualityCondition clst
let new_AssignmentCondition clst = _new_AssignmentCondition clst
let new_RewriteCondition clst = _new_RewriteCondition clst
let new_SortTestCondition clst = _new_SortTestCondition clst
let new_ModelCheckResult clst = _new_ModelCheckResult clst
let new_RewriteGraph clst = _new_RewriteGraph clst
let new_StrategyRewriteGraph clst = _new_StrategyRewriteGraph clst
let new_Substitution clst = _new_Substitution clst
let new_Hook clst = _new_Hook clst

  let rec swig_val t v = 
    match v with
        C_enum e -> enum_to_int t v
      | C_list l -> Swig.C_list (List.map (swig_val t) l)
      | C_array a -> Swig.C_array (Array.map (swig_val t) a)
      | _ -> Obj.magic v

